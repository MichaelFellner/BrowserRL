<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Learn Value Iteration!</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <link rel="stylesheet" href="styles.css">
  <style>
    /* Pulse animation for step-by-step next button */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    /* Tutorial part-specific visibility */
    .tutorial-part-1-only {
      display: none;
    }
    
    .tutorial-part-1 .tutorial-part-1-only {
      display: block;
    }
    
    /* Explicitly hide part-1-only elements in other parts */
    body.tutorial-part-2 .tutorial-part-1-only,
    body.tutorial-part-3 .tutorial-part-1-only,
    body.tutorial-part-4 .tutorial-part-1-only {
      display: none !important;
    }
  </style>
</head>
<body>
  <header>
    <h1>Learn Value Iteration!</h1>
    <p>
      <span id="header-subtitle">Learn how value iteration works step by step</span>
      <br>
      <a href="https://michaelfellner.github.io" style="color: #bbdefb; text-decoration: underline; font-weight: 500;">‚Üê Back to Homepage</a>
    </p>
    <div class="mode-toggle">
      <button class="mode-btn active" id="introduction-mode-btn" onclick="switchToIntroductionMode()">Introduction</button>
      <button class="mode-btn" id="tutorial-mode-btn" onclick="switchToTutorialMode()">Tutorial Mode</button>
      <button class="mode-btn" id="playground-mode-btn" onclick="switchToPlaygroundMode()">Playground Mode</button>
    </div>
  </header>

  <!-- Introduction Mode Content -->
  <main class="introduction-only">
    <section class="introduction-section">
      <div class="introduction-content">
        <h2>Value Iteration: How to Solve a Maze</h2>
        <p>
          Draw a path connecting the green square to the purple one, then click "run algorithm". Behind the scenes, <i>Value Iteration</i> will calculate 
          the best way for the green square to complete the maze you just drew. Afterwards, click "Start Tutorial" if you want to learn more and understand
          why this algorithm is so important to know before going further in reinforcement learning.
        </p>
      </div>
    </section>
  </main>

  <!-- Tutorial Mode Content - Side by Side Layout -->
  <div class="tutorial-only tutorial-container-wrapper">
    
    <!-- Tutorial Header (Above Both Panels) -->
    <div class="tutorial-global-header">
      <h2 id="tutorial-main-title">Tutorial Part 1: State, Actions, and the Value Function</h2>
      <div class="tutorial-navigation">
        <button onclick="switchTutorialPart(1)" id="part-1-btn-global" class="tutorial-nav-btn active">Part 1</button>
        <button onclick="switchTutorialPart(2)" id="part-2-btn-global" class="tutorial-nav-btn">Part 2</button>
        <button onclick="switchTutorialPart(3)" id="part-3-btn-global" class="tutorial-nav-btn">Part 3</button>
        <button onclick="switchTutorialPart(4)" id="part-4-btn-global" class="tutorial-nav-btn">Part 4</button>
      </div>
    </div>

    <!-- Tutorial Content and Algorithm Side by Side -->
    <div class="tutorial-container">
      
      <!-- Tutorial Content (Left Side) -->
      <section id="tutorial-explanation" class="tutorial-content-panel">
        <!-- Tutorial Part 1 -->
        <div id="tutorial-part-1" class="tutorial-part">
          <div class="tutorial-step">
            <h3>Introduction</h3>
            <p>Welcome to the Value Iteration Tutorial! Our goal is to understand this algorithm on the right. <b>NOTE:</b> Don't worry about understanding it right now, we 
                will walk through each line throughout this tutorial.</p>
                </div>
            <div class="tutorial-step"> 
                <h3>Let's Learn Some Terms</h3>
            <p>
                The green square below is your <b>agent</b>. Each tile the agent can go to is a <b>state</b>. The agent can take <b>actions</b> 
                that determine which state it goes to next. Try drawing a path and moving the agent around using the actions
                 (up, down, left, right). You'll see in the bottom left which state the agent is at.  
            </p>
            <p>If the agent reaches the goal (the purple square), then it gets 10 <b>reward</b>. Or in other words, 
                goal states ‚Äì states where the agent is at the goal ‚Äì, have 10 reward. Every other state that isn't at the goal has 0 reward.</p>
          </div>

          <div class="tutorial-step"> 
                <h3>A Very Important Term: What is Value?</h3>
            <p>
                Every state has ZERO reward except for the ones that touch the goal!? How will the agent figure out where to go? Which next state 
                is best for the agent to go to?
            </p>
            <p>This is where the notion of <b>value</b> comes in. Value is different than reward.
                 Value takes into account the potential of a state ‚Äì how well it can lead to future rewards, even if the state itself offers no reward. 
          </div>
          
          <div class="tutorial-step">
            <h3>Putting it All Together</h3>
            <p>
                The point of this algorithm, Value Iteration, is to learn the value of each state. We are given the reward ‚Äì but need to know which 
                states have the best potential for leading to reward. That way, when the agent is thinking about which direction to go
                 despite every future state all having zero reward, the agent can see which next state has the highest Value, and go there. 
                By continuously going  to the next states that have the most value, 
                the agent will keep taking optimal actions and manage to get the most amount of reward in the shortest amount of steps. 
                The roadmap an agent uses to navigate the maze is called a <b>policy</b> and if we always know which next state is best to go to,
                then we have an <b>optimal policy</b>.  
            </p>
          </div>
          <div class="tutorial-step">
            <h3><b>Experiment Below</b></h3>
            <p>
                First run value iteration to get a value for each state. Then feel free to manually move the agent either using the button controls or your <b>arrow keys</b>. See how 
                the value changes depending on where the agent moves to. Do the changes make sense?
            </p>
          </div>
        </div>

        <!-- Tutorial Part 2 -->
        <div id="tutorial-part-2" class="tutorial-part" style="display: none;">
          <div class="tutorial-step">
            <h3>Time to get Technical</h3>
            <p>We just learned about states, value, actions, and reward. Let's look at some of the technical ways the pros talk about these things üòé</p>
            <p><b>States:</b> The current state is often referred to simply as <b>s</b>, and the next state is <b>s'</b>.
                 Every single possible state is referred to as the state-space, or <b>S</b> (yes the uppercase is important). Importantly, s and s' are variables. 
                 They're used to talk about what to do at some specific state in general. 
                 For example, you could say "for any s, take the action that brings you to the s' with the highest value". 
            </p>
            <p>
                <b>Actions:</b> An action variable is <b>a</b>. The set of all actions that can be taken at some specific state is <b>A(s)></b>. 
                Some states, don't allow for some actions, like trying to go down while already at the bottom of the screen. 
            </p>
            <p>
                <b>Reward: </b><i>Technically</i> what is meant by "state s has reward x", is actually saying that there is a reward function, <b>r</b>, and r(s) = x.  
            </p>
            <p>
                <b>Value: </b>Similar to reward, value is also actually a function. We can refer to the value of a state as v(s), or a next state, v(s'). 
                 Unlike the reward function, we aren't given the correct value function at the start. The whole point of Value Iteration 
                 is to learn the correct value function when all we have is the reward function. 
            </p>
            <p>We can refer to the current value function as V, 
                which is meant to refer to how there is a whole function that can take in any state and output a value. 
                 So casually, the way this algorithm works is by starting out with a bad value function V, then some calculations and updates are made,
                  and we then create a new value function, V'.  Then we make V' the new V and update things again. 
                We keep improving the value function until the improvements between V and V' are so small that V can barely improve anymore.
            </p>
          </div>
        
          <div class="tutorial-step">
            <h3><span data-highlight-part="2">Iteratively Improving the Value Function</span></h3>
            <p>With our technical terms done we can start deciphering the algorithm on the right. First let's understand the orange part. These lines are all about how we start with a bad value function V, get a better one V', and then have V' become V and start the process over again. </p>

<p><b>Line 1:</b> We start with an inaccurate value function that's randomly initialized, or just assigns a value to zero to each state.</p>

<p><b>Lines 2 & 8:</b> Line 2 starts a loop, meaning that everything that happens beneath it keeps happening over and over again until the condition on line 8 is met. The specifics of line 8 and how the loop stops are in the next text blurb. But for now just know that everything in between lines 2 and 8 happen multiple times. We can also see that line 2 and 8 are on the same level of indentation. This is a means of signalling that line 8 is what has the power to stop the loop started on line 2. </p>

<p><b>Line 4:</b> Line 4 starts another loop. What line 4 is saying is that we are going to go through every single state, and then use it to do stuff on lines 5 and 6 (because lines 5 and 6 are indented below line 4. So we have a loop started on line 2, and then another loop started on line 4. The reason for this is because for value iteration to work, we need to loop through every single state (as per line 4), and we are going to need to loop through every single state <i>multiple times</i> (as per line 2).</p>

<p><b>Line 5:</b> So we're going through each state (as per line 4). We have our current bad value function V that will give us the wrong value for whatever state we're at, v(s). Line 5 is about how we go state by state and find a more accurate value for it ‚Äì v'(s). (Once we've gotten v'(s) for every single state, we have a whole new value function V', which we hope is superior to the current value function V). How v'(s) is calculated is in tutorial part 3. </p>

<p><b>Line 7:</b> After getting better values for every individual state, we have a whole new value function, V'. Line 7 simply says to now let V' be the current value function V, and then if the condition on line 8 isn't met, we start looping through every single state yet again. </p>
          </div>
          




        <div class="tutorial-step">
            <h3><span data-highlight-part="2-alt">How we Stop</span></h3>
            <p>Casually, the way we stop is by checking if the difference between V and V' is small. Are any improvements to the value function barely any better, or even resulting in no new improvements at all? At that point, we stop and now have a good value function. So in order to do this, we need to track the difference between V and V'. We do so by tracking the largest difference that V gives for a state and V' gives for a state. </p>

            <p><b>Line 3:</b> Line 3 initializes a variable, delta, to be zero. This is the variable that's going to track the biggest change between V and V'. </p>

            <p><b>Line 6:</b> We just calculated a new value for some state, v(s') on line 5. Line 6 is a way of keeping the delta to be the biggest (absolute) difference between v(s) and v(s'). This line might be easiest to understand by just carefully looking it over and thinking about it. </p>

            <p><b>Line 8:</b> If delta is less than a small threshold value theta, we stop the whole thing.</p>

          </div>
        <div class="tutorial-step">
            <h3><b>See the Value Function Improve Live</b></h3>
            <p>Click "Live Algorithm" after drawing a path and see the value of each state become more accurate! <b>You can click "Live Algorithm" multiple times to run additional iterations</b> and watch the value function continue to improve.</p>
            <p>As the algorithm runs, you'll see a color-coded visualization: <b>red states have lower values</b> and <b>green states have higher values</b>. The <b>arrows show the best action</b> (direction to move) that the algorithm has determined for each state.</p>
          </div>


        </div>

        
        
        

        <!-- Tutorial Part 3 -->
        <div id="tutorial-part-3" class="tutorial-part" style="display: none;">

          
          <div class="tutorial-step">
            <h3><span data-highlight-part="3">How the Value Function Improves</span></h3>
            <p>We can now understand the purple highlighted part. The way it works is that it finds the action that maximizes r(s') + Œ≥V(s'). s' means next state. Each action brings you to a different s' (most of the time, sometimes multiple actions can lead to the same next state). r(s') is the reward of the next state, and Œ≥V(s') is the value of the next state, multiplied by a constant Œ≥.</p>
            <p>Œ≥ is the <b>discount rate</b>, and this determines how much the value of the next state should affect the current state. If it's 0, then that means we don't care about the value of the next state at all, therefore we only care about the reward. If it's 1 then that means we really care about the value of the next state. Œ≥ often equals 0.9, but in the background of this website, Œ≥ is actually set to 1, so it doesn't really matter that much. You can experiment more with Œ≥ in playground mode.</p>
            <p>To bring it all together, all the highlighted line is doing now is checking which action leads to the greatest r(s') + Œ≥V(s'), and then updates V(s) to be that maximum r(s') + Œ≥V(s').</p>
          </div> 

          <div class="tutorial-step">
            <h3><b>View Things Step-by-Step</b></h3>
            <p>
                You can now go step by step and see the whole picture of what's going on in this algorithm at the closest level of detail. 
                Press the step by step button and you'll be able to see live how the right side of Line 5 is calculated. <b>After clicking 
                step-by-step, click the next button on the right of the bottom row to iterate through each state.</b>
            </p>
          </div>    
        </div>

        <!-- Tutorial Part 4 -->
        <div id="tutorial-part-4" class="tutorial-part" style="display: none;">
          <div class="tutorial-step">
            <h3>Congratulations!</h3>
            <p>You've completed the Value Iteration tutorial! You now understand the core concepts of:</p>
            <ul>
              <li><strong>States and Actions</strong> - The building blocks of any reinforcement learning environment</li>
              <li><strong>Value Functions</strong> - How we estimate the worth of being in different states</li>
              <li><strong>The Iterative Process</strong> - How value iteration gradually improves our estimates</li>
              <li><strong>Policy Extraction</strong> - How optimal actions emerge from accurate value functions</li>
            </ul>
          </div>
          
          <div class="tutorial-step">
            <h3><span data-highlight-part="4">Advanced Caveats</span></h3>
            <p>This whole time we've actually been looking at a slightly simplified version of value iteration. The blue parts are parts that were removed in steps 1-3.</p>
            <ul>
              <li><b>P(s'|s,a):</b> This part is relevant if actions operated probabilistically. Because this whole time we've been in a deterministic environment, it was irrelevant. But what this part means is "the probability of going to state s' given you're in state s and taking action a.</li>
              <li><b>r(s,a,s'):</b> Technically, the reward function is best described not just as r(s'), but as a function of the current state you're in 's', the action you're taking 'a', and also the state you end up in, s' (hence r(s,a,s')). For this environment, r(s') was good enough, but imagine in a different environment, there's some state s', but to get to it from the north you must go through lava while walking on your hands, but to get to it from the south, you simply walk through an air conditioned hallway. In this case, you don't want the reward to just factor in the destination, but the journey as well.</li>
              <li><b>‚àë<sub>s'</sub>:</b> This last little part... is actually a huge deal! In a deterministic environment, it is not necessary. A "deterministic environment", meaning that each action leads to only one next state 100% of the time. This website is a deterministic environment. But in a probabilistic environment, where actions can potentially lead to multiple different states, this summation term is crucial. What this term means is that for each action, we can't just take into account r(s') + Œ≥V(s') for a single next state, but instead we have to take into account r(s') + Œ≥V(s') for every potential next state! We sum the r(s') + Œ≥V(s') for <i>every</i> possible next state, and weigh each [r(s') + Œ≥V(s')] by the probability of ending up in that s'. This adds another loop to the value iteration algorithm and causes things to move much slower. It is actually the nature of a probabilistic environment that is a big reason for why <i>reinforcement learning</i> is used in many cases instead of value iteration.</li>
            </ul>
          </div>
          
          <div class="tutorial-step" style="text-align: center; background: #e8f5e9; border: 2px solid #4CAF50;">
            <h3 style="color: #2e7d32; margin-bottom: 1rem;">üöÄ Ready to Explore?</h3>
            <p style="margin-bottom: 1.5rem; color: #555;">Now that you understand the theory, experiment with different parameters and environments!</p>
            <button onclick="switchToPlaygroundMode()" class="btn-primary" style="padding: 12px 24px; font-size: 16px; font-weight: 600;">Go to Playground Mode</button>
          </div>
        </div>
      </section>
      <!-- Algorithm Display (Right Side) -->
      <section class="algorithm-panel">
        <h3>Value Iteration Algorithm</h3>
        <div class="algorithm-content">
          <div style="margin-bottom: 1rem;"><strong>1.</strong> <span data-highlight-part="2"><em>V</em> to arbitrary value function; e.g., <em>V(s)</em> = 0 for all <em>s</em></span></div>
          <div style="margin-bottom: 1rem;"><strong>2.</strong> <strong>repeat</strong></div>
          <div style="margin-left: 2rem; margin-bottom: 1rem;"><strong>3.</strong> <span data-highlight-part="2-alt">Œî ‚Üê 0</span></div>
          <div style="margin-left: 2rem; margin-bottom: 1rem;"><strong>4.</strong> <span data-highlight-part="2"><strong>for each</strong> <em>s</em> ‚àà <em>S</em></span></div>
          <div style="margin-left: 4rem; margin-bottom: 1rem;">
            <strong>5.</strong> <span data-highlight-part="2"><em>V'(s)</em> ‚Üê</span> 
            <span data-highlight-part="3">max<sub>a‚ààA(s)</sub></span>
            <span class="math-complete-only" data-highlight-part="4">‚àë<sub>s'</sub> P(s'|s,a)</span>
            <span data-highlight-part="3">[<span class="math-simple-only"><em>r(s')</em></span><span class="math-complete-only"><em>r(s,a,s')</em></span> + Œ≥ <em>V(s')</em>]</span>
          </div>
          <div style="margin-left: 4rem; margin-bottom: 1rem;"><strong>6.</strong> <span data-highlight-part="2-alt">Œî ‚Üê max(Œî, |<em>V'(s)</em> - <em>V(s)</em>|)</span></div>
          <div style="margin-left: 2rem; margin-bottom: 1rem;"><strong>7.</strong> <span data-highlight-part="2"><em>V</em> ‚Üê <em>V'</em></span></div>
          <div style="margin-bottom: 1.5rem;"><strong>8.</strong> <span data-highlight-part="2-alt"><strong>until</strong> Œî ‚â§ Œ∏</span></div>
          
          <!-- Source Note -->
          <!-- <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #4a5568; font-size: 11px; color: #a0aec0; text-align: center;">
            <em>Source: insertlater.com</em>
          </div> -->
        </div>
      </section>

    </div>
    </div>
  </div>

  <!-- Main Layout with Canvas + Actions + Parameters -->
  <main>
    <div class="main-layout">
      
      <!-- Actions Panel (Left) - Playground Mode Only -->
      <div class="actions-panel playground-only">
        <div class="playground-section">
          <h4>üöÄ Actions</h4>
          <div class="playground-actions">
            <button onclick="runValueIterationClientSide()" class="btn-primary">Run Value Iteration</button>
            <button onclick="runLiveValueIteration()" class="btn-secondary">Live Animation</button>
            <button onclick="runLiveValueIteration_step_by_step()" class="btn-tutorial">Step-by-Step Mode</button>
            <button onclick="followValuePolicy()" class="btn-accent">Follow Policy</button>
          </div>

          <!-- Manual Controls -->
          <div style="margin-top: 1rem;">
            <h5 style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #666; text-transform: uppercase;">Manual Control</h5>
            <div class="dpad-grid" style="max-width: 120px; margin: 0;">
              <div></div>
              <button onclick="manualMove(0)">‚Üë</button>
              <div></div>
              <button onclick="manualMove(2)">‚Üê</button>
              <div style="font-size: 10px;">move</div>
              <button onclick="manualMove(3)">‚Üí</button>
              <div></div>
              <button onclick="manualMove(1)">‚Üì</button>
              <div></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Actions Panel for Tutorial/Introduction modes -->
      <div class="actions-panel non-playground-actions">
        
        <!-- Main Actions -->
        <div class="sidebar-section">
          <h3>üöÄ Actions</h3>
          
          <!-- Introduction Mode Actions -->
          <div class="introduction-only">
            <div class="button-row">
              <button onclick="runValueIterationDemo()" class="btn-primary">Run Algorithm</button>
            </div>
            <div class="button-row">
              <button onclick="followOptimalPath()" id="follow-path-btn" class="btn-secondary" style="display: none;">üéØ Follow Path</button>
            </div>
            <div id="intro-status" class="status-display" style="display: none; margin-top: 0.5rem;">
              <strong>Status:</strong> <span id="status-text">Ready</span>
            </div>
          </div>

          <!-- Tutorial Mode Actions -->
          <div class="tutorial-only">
            <div id="tutorial-part-1-controls" class="tutorial-controls-part">
              
              <div class="button-row">
                <button onclick="runValueIterationClientSide()" class="btn-primary">Run Value Iteration</button>
              </div>
              <div class="button-row">
                <button onclick="followValuePolicy()" class="btn-accent">Follow Policy</button>
              </div>
            </div>

            <div id="tutorial-part-2-controls" class="tutorial-controls-part" style="display: none;">
            <!-- Live Algorithm and Follow Policy for Part 2 -->
            <div style="margin-top: 0rem;">
                <h4 style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Live Mode</h4>
                <div class="button-row">
                <button onclick="runTutorialLiveValueIteration()" class="btn-secondary">Live Algorithm</button>
                </div>
                <div class="button-row">
                <button onclick="followValuePolicy()" class="btn-accent">Follow Live Policy</button>
                </div>
            </div>
            </div>

            <div id="tutorial-part-3-controls" class="tutorial-controls-part" style="display: none;">
              <!-- Only Step-by-Step Mode for Part 3 -->
              <div style="margin-top: 0rem;">
                <h4 style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Step-by-Step Mode</h4>
                <div class="button-row">
                  <button onclick="runLiveValueIteration_step_by_step()" class="btn-tutorial">Step-by-Step</button>
                </div>
              </div>
            </div>
          </div>
        </div>
                    
        <!-- Introduction Tutorial Prompt -->
        <div class="sidebar-section introduction-only">
          <h3>Tips</h3>
          <div class="button-row">
            <ul><li>Click "reset agent" if the green square gets stuck in an inifinite loop.</li>
            <li>
                Click "reset all" to try a new path.
            </li>
        <li>
            You can change the size of the maze by selecting a larger canvas size at the top-left of the maze.
        </li></ul>
          </div>
        </div>

        <div class="sidebar-section introduction-only">
          <h3>üéì Learn More</h3>
          <div class="button-row">
            <button onclick="switchToTutorialMode()" class="btn-tutorial">Start Tutorial</button>
          </div>
        </div>

        <!-- Manual Movement (Tutorial only) -->
        <div class="collapsible-section tutorial-only">
          <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <h3>üïπÔ∏è Manual Control</h3>
            <span class="collapsible-toggle">‚ñº</span>
          </div>
          <div class="collapsible-content">
            <div class="dpad-grid">
              <div></div>
              <button onclick="manualMove(0)">‚Üë</button>
              <div></div>
              <button onclick="manualMove(2)">‚Üê</button>
              <div>move</div>
              <button onclick="manualMove(3)">‚Üí</button>
              <div></div>
              <button onclick="manualMove(1)">‚Üì</button>
              <div></div>
            </div>
          </div>
        </div>

        <!-- Keyboard Controls Tip (Tutorial Part 1 only) -->
        <div class="sidebar-section tutorial-only tutorial-part-1-only">
          <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 12px; margin-top: 0.5rem;">
            <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #1976d2;">üí° Pro Tip</h4>
            <p style="margin: 0; font-size: 13px; color: #424242; line-height: 1.4;">
              You can also use your <strong>keyboard arrow keys</strong> to move the agent around the canvas!
            </p>
          </div>
        </div>

        <!-- Tutorial Settings (Part 2 only) -->
        <div class="collapsible-section tutorial-only">
          <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <h3>Live Animation Settings</h3>
            <span class="collapsible-toggle">‚ñº</span>
          </div>
          <div class="collapsible-content expanded" style="display: block;">
            <div class="input-group">
              <label>Animation Speed:</label>
              <input id="tutorialDelayMs" type="range" min="1" max="200" value="50" oninput="updateSpeedDisplay(this.value)">
              <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
                <span>Faster</span>
                <span id="speedValue">50ms</span>
                <span>Slower</span>
              </div>
            </div>
            <div class="input-group">
              <label>Iterations:</label>
              <input id="tutorialLiveIters" type="number" value="1" min="1" max="5">
            </div>
          </div>
        </div>

        <!-- Tutorial Navigation (Single, Dynamic) -->
        <div class="sidebar-section tutorial-only">
          <h3>üìç Navigation</h3>
          <div class="button-row">
            <button id="tutorial-nav-left" onclick="switchToIntroductionMode()" class="btn-secondary">‚Üê Back to Intro</button>
            <button id="tutorial-nav-right" onclick="switchTutorialPart(2)" class="btn-primary">Part 2 ‚Üí</button>
          </div>
        </div>

        <!-- Hidden status elements (keep for JavaScript compatibility) -->
        <div style="display: none;">
          <div id="agentPosition" class="playground-only">The agent is currently at state (60, 540)</div>
          <div id="tutorialAgentPosition" class="tutorial-only">The agent is currently at state (60, 540)</div>
          <div id="iterationCount">Iterations: -</div>
          <div id="deltaDisplay">Œî: -</div>
          <div id="pathCheckResult">Path: -</div>
        </div>

      </div>
      
      <!-- Canvas Section with Controls and Status Bars -->
      <div class="canvas-and-controls">
        <!-- Compact Canvas Controls Bar -->
        <div class="canvas-controls-bar">
          <!-- Canvas Size Dropdown -->
          <div class="canvas-size-compact">
            <label>Canvas:</label>
            <select onchange="resizeCanvas(this.value)">
              <option value="small" selected>Small (600√ó360)</option>
              <option value="medium">Medium (800√ó480)</option>
              <option value="large">Large (1000√ó600)</option>
            </select>
          </div>

          <!-- Reset Buttons -->
          <div class="canvas-reset-buttons">
            <button onclick="resetGreenBox()" class="btn-mini btn-primary" title="Reset agent position">Reset Agent</button>
            <button onclick="resetEverything()" class="btn-mini btn-danger" title="Reset everything">Reset All</button>
          </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
          <canvas id="c" width="1000" height="600"></canvas>
        </div>

        <!-- Canvas Status Bar with External Step-by-Step Buttons -->
        <div class="canvas-status-bar-wrapper">
          <!-- Left: Stop Button (Outside) -->
          <div id="stepByStepStopContainer" style="display: none;">
            <button onclick="stopStepByStep()" class="btn-mini btn-danger">üõë Stop</button>
          </div>
          
          <!-- Center: Canvas Status Bar -->
          <div class="canvas-status-bar">
            <!-- Status Info -->
            <div class="status-info">
            <div id="agentPositionCompact" class="agent-status-compact">
                State: (60, 540)
            </div>
            <div id="currentRewardCompact" class="agent-status-compact">
                Reward: 0
            </div>
            <div id="currentValueCompact" class="agent-status-compact">
                Value: -
            </div>
            </div>

            <div class="status-info">
              <div id="iterationCountCompact" class="iteration-status-compact">
                Iterations: -
              </div>
              <div id="deltaDisplayCompact" class="iteration-status-compact">
                Œî: -
              </div>
            </div>
          </div>
          
          <!-- Right: Next Step Button (Outside) -->
          <div id="stepByStepNextContainer" style="display: none;">
            <button onclick="nextStepClick()" class="btn-mini btn-primary" style="background: #ff5722; border: 2px solid #d84315; font-weight: bold; font-size: 14px; padding: 8px 16px; box-shadow: 0 2px 8px rgba(255, 87, 34, 0.3); animation: pulse 2s infinite;">‚ñ∂Ô∏è Next Step</button>
          </div>
        </div>

        <!-- Step-by-Step Status Bar (hidden by default) -->
        <div id="stepByStepStatusBar" style="display: none;">
          <div class="status-info" style="width: 100%; justify-content: center;">
            <div id="stepByStepStatus" style="font-size: 12px; font-weight: 600; color: black; padding: 8px 12px; text-align: center; font-family: 'Courier New', monospace; line-height: 1.3;">
              Ready to start step-by-step analysis...
            </div>
          </div>
        </div>
      </div>

      <!-- Parameters Panel (Right) - Playground Mode Only -->
      <div class="parameters-panel playground-only">
        <div class="playground-section">
          <h4>‚öôÔ∏è Parameters</h4>
          <div class="playground-params">
            <div class="input-group">
              <label>Discount Factor (Œ≥):</label>
              <input id="gamma" type="number" step="0.01" value="0.99" onchange="updateParameterDisplays()">
            </div>
            <div class="input-group">
              <label>Convergence Threshold (Œµ):</label>
              <input id="threshold" type="number" step="1e-6" value="0.0001" onchange="updateParameterDisplays()">
            </div>
            <div class="input-group">
              <label>Reward Function:</label>
              <select id="rewardFunction" onchange="updateParameterDisplays()">
                <option value="zero">Goal Only</option>
                <option value="negative_distance">Negative distance</option>
              </select>
            </div>
            <div class="input-group">
              <label>Live Animation Delay (ms):</label>
              <input id="delayMs" type="number" value="120" min="10" max="2000">
            </div>
            <div class="input-group">
              <label>Iterations per Run:</label>
              <input id="liveIters" type="number" value="1" min="1" max="10">
            </div>
          </div>
        </div>
      </div>

    </div>
  </main>

  <script src="draw.js"></script>
  <script>
    // Store the original function references
    let originalFollowValuePolicy;
    let originalFollowOptimalPath;

    // Function to update speed display
    function updateSpeedDisplay(value) {
      const speedDisplay = document.getElementById('speedValue');
      if (speedDisplay) {
        speedDisplay.textContent = `${value}ms`;
      }
    }
    
    // Collapsible section functionality
    function toggleCollapsible(header) {
      const content = header.nextElementSibling;
      const toggle = header.querySelector('.collapsible-toggle');
      
      if (content.classList.contains('expanded')) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
        content.style.display = 'none';
      } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
        content.style.display = 'block';
      }
    }
    
    // Update canvas size dropdown when canvas is resized
    function updateCanvasSizeDropdown(size) {
      const dropdown = document.querySelector('.canvas-size-compact select');
      if (dropdown) {
        dropdown.value = size;
      }
    }
    
    // Update controls bar width to match canvas width and handle step-by-step status bar
    function updateControlsBarWidth(size) {
      const controlsBar = document.querySelector('.canvas-controls-bar');
      const statusBarWrapper = document.querySelector('.canvas-status-bar-wrapper');
      const stepByStepStatusBar = document.getElementById('stepByStepStatusBar');
      const canvasSizes = {
        small: '600px',
        medium: '800px', 
        large: '1000px'
      };
      
      if (controlsBar && canvasSizes[size]) {
        controlsBar.style.width = canvasSizes[size];
      }
      
      // Update status bar wrapper width to match canvas
      if (statusBarWrapper && canvasSizes[size]) {
        statusBarWrapper.style.width = canvasSizes[size];
      }
      
      // Update step-by-step status bar
      if (stepByStepStatusBar && canvasSizes[size]) {
        stepByStepStatusBar.style.width = canvasSizes[size];
        // Ensure minimum width for step-by-step status bar
        const minWidth = Math.max(parseInt(canvasSizes[size]), 800);
        stepByStepStatusBar.style.minWidth = `${minWidth}px`;
      }
    }
    
    // Update compact status displays when original ones are updated
    function updateCompactStatusDisplays() {
      // Update agent position display (single display for both modes)
      const agentPosition = document.getElementById('agentPosition');
      const tutorialAgentPosition = document.getElementById('tutorialAgentPosition');
      const agentPositionCompact = document.getElementById('agentPositionCompact');
      
      if (agentPositionCompact) {
        let text = '';
        if (agentPosition && agentPosition.textContent) {
          text = agentPosition.textContent;
        } else if (tutorialAgentPosition && tutorialAgentPosition.textContent) {
          text = tutorialAgentPosition.textContent;
        }
        
        if (text) {
          const match = text.match(/\((\d+), (\d+)\)/);
          if (match) {
            agentPositionCompact.textContent = `State: (${match[1]}, ${match[2]})`;
          }
        }
      }
      
      // Update iteration count
      const iterationCount = document.getElementById('iterationCount');
      const iterationCountCompact = document.getElementById('iterationCountCompact');
      if (iterationCount && iterationCountCompact) {
        iterationCountCompact.textContent = iterationCount.textContent;
      }
      
      // Update delta display (always show, not just in playground mode)
      const deltaDisplay = document.getElementById('deltaDisplay');
      const deltaDisplayCompact = document.getElementById('deltaDisplayCompact');
      if (deltaDisplay && deltaDisplayCompact) {
        deltaDisplayCompact.textContent = deltaDisplay.textContent;
      }
    }
    
    // Updated layout function to prevent shifting
    function updateCanvasControlsLayout() {
      const mainLayout = document.querySelector('.main-layout');
      if (mainLayout) {
        mainLayout.style.alignItems = 'flex-start'; // Prevent centering that causes shifts
      }
      
      const canvasAndControls = document.querySelector('.canvas-and-controls');
      if (canvasAndControls) {
        canvasAndControls.style.position = 'relative';
        canvasAndControls.style.width = 'auto';
      }
      
      const actionsPanel = document.querySelector('.actions-panel');
      if (actionsPanel) {
        actionsPanel.style.position = 'relative';
        actionsPanel.style.flexShrink = '0'; // Prevent shrinking
      }
    }
    
    // Set up observers to watch for changes in the original status displays
    function setupStatusObservers() {
      const elementsToWatch = [
        'agentPosition',
        'tutorialAgentPosition', 
        'iterationCount',
        'deltaDisplay'
      ];
      
      elementsToWatch.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          const observer = new MutationObserver(updateCompactStatusDisplays);
          observer.observe(element, { 
            childList: true, 
            subtree: true, 
            characterData: true,
            attributes: true,
            attributeFilter: ['style']
          });
        }
      });
    }
    
    // Override the original resizeCanvas function to update dropdown and controls width
    const originalResizeCanvas = window.resizeCanvas;
    window.resizeCanvas = function(size) {
      if (originalResizeCanvas) {
        originalResizeCanvas(size);
      }
      updateCanvasSizeDropdown(size);
      updateControlsBarWidth(size);
    };
    
    // Override switchToTutorialMode to add scroll to top
    const originalSwitchToTutorialMode = window.switchToTutorialMode;
    window.switchToTutorialMode = function() {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("üõë Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchToTutorialMode) {
        originalSwitchToTutorialMode();
      }
      
      // Initialize navigation for part 1
      updateTutorialNavigation(1);
      
      // Initialize global header for part 1
      updateGlobalTutorialHeader(1);
      
      // Auto-expand manual controls section
      setTimeout(() => {
        const manualControlsHeader = document.querySelector('.collapsible-section.tutorial-only .collapsible-header');
        if (manualControlsHeader) {
          const content = manualControlsHeader.nextElementSibling;
          if (content && !content.classList.contains('expanded')) {
            toggleCollapsible(manualControlsHeader);
          }
        }
        
        // Hide live settings initially (will be shown in part 2)
        const liveSettingsHeaders = document.querySelectorAll('.collapsible-section.tutorial-only .collapsible-header h3');
        liveSettingsHeaders.forEach(header => {
          if (header.textContent.includes('Live Animation Settings')) {
            const liveSettingsSection = header.closest('.collapsible-section');
            if (liveSettingsSection) {
              liveSettingsSection.style.display = 'none';
            }
          }
        });
      }, 100);
      
      // Smooth scroll to top of page
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Function to update tutorial navigation buttons
    function updateTutorialNavigation(partNumber) {
      const leftButton = document.getElementById('tutorial-nav-left');
      const rightButton = document.getElementById('tutorial-nav-right');
      
      if (!leftButton || !rightButton) return;
      
      switch(partNumber) {
        case 1:
          leftButton.textContent = '‚Üê Back to Intro';
          leftButton.onclick = () => switchToIntroductionMode();
          rightButton.textContent = 'Part 2 ‚Üí';
          rightButton.onclick = () => switchTutorialPart(2);
          break;
        case 2:
          leftButton.textContent = '‚Üê Part 1';
          leftButton.onclick = () => switchTutorialPart(1);
          rightButton.textContent = 'Part 3 ‚Üí';
          rightButton.onclick = () => switchTutorialPart(3);
          break;
        case 3:
          leftButton.textContent = '‚Üê Part 2';
          leftButton.onclick = () => switchTutorialPart(2);
          rightButton.textContent = 'Part 4 ‚Üí';
          rightButton.onclick = () => switchTutorialPart(4);
          break;
        case 4:
          leftButton.textContent = '‚Üê Part 3';
          leftButton.onclick = () => switchTutorialPart(3);
          rightButton.textContent = 'Playground ‚Üí';
          rightButton.onclick = () => switchToPlaygroundMode();
          break;
      }
    }
    
    // Function to update global tutorial header
    function updateGlobalTutorialHeader(partNumber) {
      const titles = {
        1: "Tutorial Part 1: State, Actions, and the Value Function",
        2: "Tutorial Part 2: Putting the \"Iteration\" in Value Iteration", 
        3: "Tutorial Part 3: Step-by-Step Analysis",
        4: "Tutorial Part 4: Final Caveats"
      };
      
      const titleElement = document.getElementById('tutorial-main-title');
      if (titleElement && titles[partNumber]) {
        titleElement.textContent = titles[partNumber];
      }
      
      // Update global navigation buttons
      const globalButtons = [
        'part-1-btn-global',
        'part-2-btn-global', 
        'part-3-btn-global',
        'part-4-btn-global'
      ];
      
      globalButtons.forEach((btnId, index) => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.classList.toggle('active', index + 1 === partNumber);
        }
      });
    }
    
    // Override switchTutorialPart to handle body classes for part-specific visibility
    const originalSwitchTutorialPart = window.switchTutorialPart;
    window.switchTutorialPart = function(partNumber) {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("üõë Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchTutorialPart) {
        originalSwitchTutorialPart(partNumber);
      }
      
      // Remove existing tutorial part classes
      document.body.classList.remove('tutorial-part-1', 'tutorial-part-2', 'tutorial-part-3', 'tutorial-part-4');
      
      // Add current tutorial part class
      document.body.classList.add(`tutorial-part-${partNumber}`);
      
      // Update navigation buttons
      updateTutorialNavigation(partNumber);
      
      // Update global header
      updateGlobalTutorialHeader(partNumber);
      
      // Ensure manual controls stay expanded
      setTimeout(() => {
        const manualControlsHeader = document.querySelector('.collapsible-section.tutorial-only .collapsible-header');
        if (manualControlsHeader) {
          const content = manualControlsHeader.nextElementSibling;
          if (content && !content.classList.contains('expanded')) {
            toggleCollapsible(manualControlsHeader);
          }
        }
        
        // Handle live animation settings visibility and expansion based on part
        const liveSettingsHeaders = document.querySelectorAll('.collapsible-section.tutorial-only .collapsible-header h3');
        let liveSettingsSection = null;
        liveSettingsHeaders.forEach(header => {
          if (header.textContent.includes('Live Animation Settings')) {
            liveSettingsSection = header.closest('.collapsible-section');
          }
        });
        if (liveSettingsSection) {
          if (partNumber === 2) {
            // Show and expand in part 2
            liveSettingsSection.style.display = 'block';
            const header = liveSettingsSection.querySelector('.collapsible-header');
            const content = liveSettingsSection.querySelector('.collapsible-content');
            if (header && content && !content.classList.contains('expanded')) {
              toggleCollapsible(header);
            }
          } else {
            // Hide in other parts
            liveSettingsSection.style.display = 'none';
          }
        }
      }, 100);
    };
    
    // Override switchToIntroductionMode to ensure proper cleanup
    const originalSwitchToIntroductionMode = window.switchToIntroductionMode;
    window.switchToIntroductionMode = function() {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("üõë Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchToIntroductionMode) {
        originalSwitchToIntroductionMode();
      }
      
      // Remove tutorial part classes when going back to introduction
      document.body.classList.remove('tutorial-part-1', 'tutorial-part-2', 'tutorial-part-3', 'tutorial-part-4');
      
      // Smooth scroll to top of page
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Override switchToPlaygroundMode to stop step-by-step
    const originalSwitchToPlaygroundMode = window.switchToPlaygroundMode;
    window.switchToPlaygroundMode = function() {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("üõë Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchToPlaygroundMode) {
        originalSwitchToPlaygroundMode();
      }
      
      // Smooth scroll to top of page
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Initialize everything when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Set up proper layout to prevent shifts
      updateCanvasControlsLayout();

      // Override followValuePolicy with position updating version
      originalFollowValuePolicy = window.followValuePolicy;
      if (originalFollowValuePolicy) {
        window.followValuePolicy = async function() {
          if (!valuePolicy || Object.keys(valuePolicy).length === 0) {
            console.warn("‚ö†Ô∏è No policy loaded. Run value iteration first.");
            alert("Please run value iteration first.");
            return;
          }
        
          stopFollowingPolicy = false;
          console.log("üìå Policy Keys:", Object.keys(valuePolicy));
        
          let steps = 0;
          while (steps < 1000) {
            if (stopFollowingPolicy) {
              console.log("üõë Policy execution stopped.");
              break;
            }
        
            const cx = Math.floor((greenBox.left + BOX / 2) / BOX) * BOX;
            const cy = Math.floor((greenBox.top + BOX / 2) / BOX) * BOX;
            const key = `${cx},${cy}`;
            const action = valuePolicy[key];
            console.log(`üîç At (${cx}, ${cy}) ‚Üí action:`, action);
        
            if (action === undefined) {
              console.warn("‚ùå No action found in policy for current position.");
              break;
            }
        
            const [dx, dy] = { 0: [0, -BOX], 1: [0, BOX], 2: [-BOX, 0], 3: [BOX, 0] }[action];
            const nx = greenBox.left + dx;
            const ny = greenBox.top + dy;
        
            greenBox.set({ left: nx, top: ny });
            canvas.renderAll();
            
            // Update agent position display after each move
            const centerX = nx + BOX / 2;
            const centerY = ny + BOX / 2;
            updateAgentPositionDisplay(centerX, centerY);
        
            const goal = getGoalCenter();
            const dist = Math.sqrt((centerX - goal.x) ** 2 + (centerY - goal.y) ** 2);
            console.log(`üìè Distance to goal: ${dist.toFixed(2)}`);
            if (dist < BOX + 1) {
              console.log("üèÅ Goal reached!");
              break;
            }
        
            await new Promise(r => setTimeout(r, 100));
            steps++;
          }
        
          console.log("üõë Finished following policy.");
        };
      }
      
      // Also override followOptimalPath for introduction mode
      originalFollowOptimalPath = window.followOptimalPath;
      if (originalFollowOptimalPath) {
        window.followOptimalPath = function() {
          // Call original function and then ensure displays are updated
          originalFollowOptimalPath();
          // The original function should handle the position updates
        };
      }

      // Set initial canvas size dropdown and controls bar width
      updateCanvasSizeDropdown('small');
      updateControlsBarWidth('small');
      
      // Set up status observers and initial compact displays
      setupStatusObservers();
      updateCompactStatusDisplays();
      
      // Initialize tutorial part 1 class if in tutorial mode
      if (document.body.classList.contains('tutorial-mode')) {
        document.body.classList.add('tutorial-part-1');
        updateTutorialNavigation(1);
        updateGlobalTutorialHeader(1);
      }
    });
// Keyboard controls for agent movement
document.addEventListener('keydown', function(event) {
  // Only allow keyboard controls if not in step-by-step mode
  if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
    return; // Don't interfere with step-by-step mode
  }
  
  // Prevent default behavior for arrow keys to avoid page scrolling
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
    event.preventDefault();
  }
  
  // Map keys to actions
  switch(event.code) {
    case 'ArrowUp':
    case 'KeyW':
      manualMove(0); // Up
      break;
    case 'ArrowDown':
    case 'KeyS':
      manualMove(1); // Down
      break;
    case 'ArrowLeft':
    case 'KeyA':
      manualMove(2); // Left
      break;
    case 'ArrowRight':
    case 'KeyD':
      manualMove(3); // Right
      break;
  }
});
// Function to get current state reward
function getCurrentStateReward(x, y) {
  if (typeof getGoalCenter !== 'function') {
    return 0;
  }
  
  const goal = getGoalCenter();
  const dist = Math.sqrt((x - goal.x) ** 2 + (y - goal.y) ** 2);
  
  if (dist < 21) { // At goal
    return 10;
  }
  
  // Get current reward function setting
  const rewardFunction = document.getElementById('rewardFunction')?.value || 'zero';
  
  if (rewardFunction === 'negative_distance') {
    // Negative distance to goal (normalized by box size)
    return -(dist / 20);
  } else {
    // Zero reward (default)
    return 0;
  }
}

// Function to get current state value
function getCurrentStateValue(x, y) {
  const stateKey = `${x},${y}`;
  
  // Check if we have values from any algorithm
  if (liveValues && liveValues.has(stateKey)) {
    return liveValues.get(stateKey);
  }
  
  // Check if at goal (fallback)
  if (typeof getGoalCenter === 'function') {
    const goal = getGoalCenter();
    const dist = Math.sqrt((x - goal.x) ** 2 + (y - goal.y) ** 2);
    if (dist < 21) {
      return 10; // Goal value
    }
  }
  
  return "-"; // No value available
}
// Function to update the displays
function updateCurrentStateDisplays(x, y) {
  const rewardDisplay = document.getElementById('currentRewardCompact');
  const valueDisplay = document.getElementById('currentValueCompact');
  
  if (rewardDisplay) {
    const reward = getCurrentStateReward(x, y);
    // Format reward display - show whole numbers for goal, decimals for negative distances
    const formattedReward = reward === 10 || reward === 0 ? reward.toString() : reward.toFixed(2);
    rewardDisplay.textContent = `Reward: ${formattedReward}`;
  }
  
  if (valueDisplay) {
    const value = getCurrentStateValue(x, y);
    if (value === "-") {
      valueDisplay.textContent = `Value: -`;
    } else if (value === "VI") {
      valueDisplay.textContent = `Value: VI run`;
    } else {
      const formattedValue = typeof value === 'number' ? value.toFixed(2) : value;
      valueDisplay.textContent = `Value: ${formattedValue}`;
    }
  }
}
  </script>
</body>
</html>