<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Learn Value Iteration!</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
  <style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #333;
  min-height: 100vh;
}

header {
  text-align: center;
  padding: 2rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

header h1 {
  color: white;
  margin: 0 0 0.5rem 0;
  font-size: 2.5rem;
  font-weight: 300;
}

header p {
  color: #e3f2fd;
  margin: 0;
  font-size: 1.1rem;
}

.mode-toggle {
  margin-top: 1rem;
  display: flex;
  justify-content: center;
  gap: 1rem;
}

.mode-btn {
  padding: 10px 20px;
  border: 2px solid white;
  background: transparent;
  color: white;
  border-radius: 25px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.mode-btn.active {
  background: white;
  color: #667eea;
}

.mode-btn:hover {
  background: rgba(255, 255, 255, 0.1);
}

.mode-btn.active:hover {
  background: white;
}

main {
  max-width: 1600px;
  margin: 2rem auto;
  padding: 0 1rem;
}

/* Updated Main Layout - Ensure main layout doesn't shift when step-by-step status appears */
.main-layout {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: none;
  margin: auto;
  flex-wrap: wrap;
}

.canvas-and-controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  position: relative;
  flex-shrink: 0;
}

.actions-panel {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding-top: 0;
  position: relative;
  flex-shrink: 0;
  width: 280px;
}

.parameters-panel {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  width: 280px;
  padding-top: 0;
  position: relative;
  flex-shrink: 0;
}

/* Show playground panels side by side in main-layout */
body.playground-mode .main-layout {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: flex-start;
  gap: 2rem;
  flex-wrap: wrap;
}

/* Ensure proper flex behavior for playground panels */
body.playground-mode .actions-panel.playground-only {
  flex: 0 0 280px;
}

body.playground-mode .parameters-panel.playground-only {
  flex: 0 0 280px;
}

/* Responsive Design */
@media (max-width: 1200px) {
  .main-layout {
    flex-direction: column !important;
    align-items: center;
    gap: 2rem;
  }

  .actions-panel,
  .parameters-panel,
  .canvas-and-controls {
    width: 100%;
    max-width: 600px;
    order: unset !important; /* Reset order on mobile */
  }
  
  /* Responsive for playground mode */
  body.playground-mode .actions-panel.playground-only,
  body.playground-mode .parameters-panel.playground-only {
    width: 100%;
    max-width: 600px;
    flex: none;
  }
}

/* Introduction mode: actions on the RIGHT of canvas */
/* Introduction and Tutorial modes: actions on the RIGHT of canvas */
body:not(.playground-mode) .main-layout {
  flex-direction: row;
}

body:not(.playground-mode) .canvas-and-controls {
  order: 1; /* Canvas first (left) */
}

body:not(.playground-mode) .actions-panel {
  order: 2; /* Actions second (right) */
}

/* Sidebar Styling (now used for actions panel) */
.sidebar-section {
  background: rgba(255, 255, 255, 0.95);
  padding: 0.75rem;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
  transition: all 0.3s ease;
}

.sidebar-section:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.sidebar-section h3 {
  margin: 0 0 0.5rem 0;
  color: #2c3e50;
  font-size: 0.9rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.sidebar-section p {
  margin: 0 0 0.5rem 0;
  color: #666;
  font-size: 12px;
  line-height: 1.3;
}

/* Collapsible sections */
.collapsible-section {
  background: rgba(255, 255, 255, 0.95);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border: 1px solid rgba(255, 255, 255, 0.3);
  overflow: hidden;
  transition: all 0.3s ease;
}

.collapsible-header {
  padding: 0.75rem;
  background: rgba(0,0,0,0.02);
  border-bottom: 1px solid rgba(0,0,0,0.1);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  transition: all 0.3s ease;
}

.collapsible-header:hover {
  background: rgba(0,0,0,0.05);
}

.collapsible-header h3 {
  margin: 0;
  font-size: 0.9rem;
  font-weight: 600;
  color: #2c3e50;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.collapsible-toggle {
  font-size: 0.8rem;
  color: #666;
  transition: transform 0.3s ease;
}

.collapsible-content {
  padding: 0.75rem;
  display: none;
}

.collapsible-content.expanded {
  display: block;
}

.collapsible-toggle.expanded {
  transform: rotate(180deg);
}

/* Canvas Section */
.canvas-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}

.canvas-controls-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 600px; /* Will be updated dynamically to match canvas */
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  backdrop-filter: blur(10px);
  transition: width 0.3s ease;
}

/* Canvas status bar wrapper to hold external buttons */
.canvas-status-bar-wrapper {
  display: flex;
  align-items: stretch; /* Keep stretch so buttons match status bar height */
  gap: 12px;
  width: 600px; /* Will be updated dynamically to match canvas */
  transition: width 0.3s ease;
}

/* Enhanced canvas status bar (now just the center part) */
.canvas-status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex: 1; /* Take up remaining space in wrapper */
  padding: 0.5rem; /* Back to original padding */
  background: rgba(255, 255, 255, 0.95);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  backdrop-filter: blur(10px);
  position: relative;
}

/* Step-by-Step Status Bar positioning */
#stepByStepStatusBar {
  margin-top: 0.5rem;
  position: relative;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.98);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  backdrop-filter: blur(10px);
  border: 2px solid #2196F3;
}

/* Step-by-Step Button Containers (now external) */
#stepByStepStopContainer,
#stepByStepNextContainer {
  display: flex;
  align-items: center;
  flex-shrink: 0;
  height: auto; /* Let it calculate naturally */
  min-height: 44px; /* Ensure minimum height matches status bar */
}

/* Ensure external buttons have proper styling and match status bar height */
#stepByStepStopContainer .btn-mini,
#stepByStepNextContainer .btn-mini {
  white-space: nowrap;
  min-width: 70px;
  font-size: 11px;
  padding: 12px 10px; /* Restore vertical padding to make buttons proper height */
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px; /* Match status bar border radius */
  min-height: 44px; /* Explicit height to match status bar */
}

/* Make the Next Step button purple like the step-by-step button */
#stepByStepNextContainer .btn-mini.btn-primary {
  background: linear-gradient(45deg, #9C27B0, #7B1FA2) !important;
  color: white !important;
  box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3) !important;
}

#stepByStepNextContainer .btn-mini.btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4) !important;
}

.status-info {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.agent-status-compact {
  font-size: 11px;
  font-weight: 600;
  color: #2e7d32;
  background: #e8f5e9;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #4CAF50;
}

.path-status-compact {
  font-size: 11px;
  font-weight: 600;
  color: #1976d2;
  background: #e3f2fd;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #2196F3;
}

.iteration-status-compact {
  font-size: 11px;
  font-weight: 600;
  color: #7b1fa2;
  background: #f3e5f5;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #9c27b0;
}

.canvas-size-compact {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.canvas-size-compact label {
  font-size: 11px;
  font-weight: 600;
  color: #2c3e50;
  margin: 0;
}

.canvas-size-compact select {
  padding: 4px 8px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 11px;
  background: white;
  cursor: pointer;
}

.canvas-reset-buttons {
  display: flex;
  gap: 0.25rem;
}

.btn-mini {
  padding: 4px 8px;
  font-size: 10px;
  font-weight: 600;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  min-width: 50px;
}

.btn-mini.btn-primary {
  background: linear-gradient(45deg, #4CAF50, #45a049);
  color: white;
  box-shadow: 0 1px 4px rgba(76, 175, 80, 0.3);
}

.btn-mini.btn-danger {
  background: linear-gradient(45deg, #f44336, #d32f2f);
  color: white;
  box-shadow: 0 1px 4px rgba(244, 67, 54, 0.3);
}

.btn-mini:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.canvas-container {
  border: 3px solid #fff;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  background: white;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

.canvas-container canvas {
  display: block;
}

/* Button Styles */
.button-row {
  display: flex;
  gap: 0.25rem;
  margin-top: 0.5rem;
  flex-wrap: wrap;
}

.btn-primary, .btn-secondary, .btn-accent, .btn-danger, .btn-tutorial {
  border: none;
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 600;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  flex: 1;
  min-width: 80px;
  text-align: center;
}

.btn-primary {
  background: linear-gradient(45deg, #4CAF50, #45a049);
  color: white;
  box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
}

.btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.btn-secondary {
  background: linear-gradient(45deg, #2196F3, #1976D2);
  color: white;
  box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
}

.btn-secondary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
}

.btn-accent {
  background: linear-gradient(45deg, #FF9800, #F57C00);
  color: white;
  box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
}

.btn-accent:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
}

.btn-danger {
  background: linear-gradient(45deg, #f44336, #d32f2f);
  color: white;
  box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
}

.btn-danger:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
}

.btn-tutorial {
  background: linear-gradient(45deg, #9C27B0, #7B1FA2);
  color: white;
  box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
}

.btn-tutorial:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4);
}

/* Compact button for single actions */
.btn-compact {
  padding: 6px 10px;
  font-size: 11px;
  min-width: 60px;
}

/* Input groups for better form organization */
.input-group {
  margin-bottom: 0.75rem;
}

.input-group label {
  margin-bottom: 0.25rem;
  font-size: 12px;
  font-weight: 600;
  color: #495057;
}

/* Playground Section Styles */
.playground-section {
  background: rgba(255, 255, 255, 0.95);
  padding: 0.75rem;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.playground-section h4 {
  margin: 0 0 0.75rem 0;
  font-size: 0.9rem;
  font-weight: 600;
  color: #2c3e50;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  border-bottom: 1px solid #e0e0e0;
  padding-bottom: 0.5rem;
}

.playground-actions {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.playground-params {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

label {
  display: block;
  margin-bottom: 0.8rem;
  font-weight: 500;
  color: #495057;
}

input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  margin-top: 4px;
  font-size: 14px;
  box-sizing: border-box;
}

input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

/* D-Pad Grid */
.dpad-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 4px;
  max-width: 150px;
  margin: 1rem auto 0 auto;
}

.dpad-grid button {
  padding: 12px;
  font-size: 16px;
  min-height: 44px;
  border-radius: 6px;
  background: #4CAF50;
  border: none;
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

.dpad-grid button:hover {
  background: #45a049;
  transform: translateY(-1px);
}

.dpad-grid div:nth-child(5) {
  background: #e0e0e0;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: #666;
}

/* Status Display */
.status-display {
  background: #e8f5e9;
  border: 1px solid #c8e6c9;
  border-radius: 8px;
  padding: 1rem;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.4;
}

.agent-position {
  font-weight: bold;
  color: #2e7d32;
  font-size: 16px;
  padding: 1rem;
  background: #e8f5e9;
  border-radius: 8px;
  text-align: center;
  border: 2px solid #4CAF50;
}

/* Size Selector */
.size-selector {
  display: flex;
  gap: 1rem;
  justify-content: center;
  flex-wrap: wrap;
}

.size-option {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border: 2px solid #ddd;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: white;
}

.size-option:hover {
  background: #f8f9fa;
  border-color: #007bff;
}

.size-option input[type="radio"] {
  width: auto;
  margin: 0;
}

.size-option input[type="radio"]:checked + span {
  font-weight: bold;
  color: #007bff;
}

.size-option:has(input[type="radio"]:checked) {
  border-color: #007bff;
  background: #e3f2fd;
}

/* Tutorial Styles */
.tutorial-step {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  padding: 1.25rem;
  border-radius: 8px;
  margin-bottom: 1rem;
  font-size: 15px;
  line-height: 1.6;
}

.tutorial-step h3 {
  color: #2c3e50;
  margin: 0 0 0.75rem 0;
  font-size: 1.2rem;
  font-weight: 600;
}

.tutorial-step p {
  margin-bottom: 1rem;
}

.tutorial-step:last-child {
  margin-bottom: 0;
}

.tutorial-only {
  display: block;
}

.playground-only {
  display: none;
}

.tutorial-nav-btn {
  padding: 8px 16px;
  margin: 0 5px;
  background: #f0f0f0;
  border: 2px solid #ddd;
  color: #666;
  border-radius: 20px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.tutorial-nav-btn.active {
  background: #2196F3;
  border-color: #2196F3;
  color: white;
}

.tutorial-nav-btn:hover {
  background: #e0e0e0;
  border-color: #bbb;
}

.tutorial-nav-btn.active:hover {
  background: #1976D2;
  border-color: #1976D2;
}

.tutorial-navigation {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

/* Tutorial Layout */
.tutorial-container-wrapper {
  max-width: 1400px;
  margin: 2rem auto 0 auto;
}

.tutorial-global-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 2rem;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.15);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.tutorial-global-header h2 {
  color: #2c3e50;
  margin: 0 0 1.5rem 0;
  font-size: 1.8rem;
  font-weight: 600;
}

.tutorial-container {
  display: flex;
  gap: 2rem;
  align-items: flex-start;
  min-height: 600px;
}

.tutorial-content-panel {
  flex: 1;
  min-width: 0;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 8px 32px rgba(0,0,0,0.15);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
  max-width: calc(100% - 600px); /* Updated for 550px algorithm panel + gap */
}

.tutorial-header {
  text-align: center;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 2px solid #e0e0e0;
}

.tutorial-header h2 {
  color: #2c3e50;
  margin: 0 0 1rem 0;
  font-size: 1.4rem;
  font-weight: 600;
}

.algorithm-panel {
  flex: 0 0 550px; /* Increased to 550px (50px wider) */
  background: #2c3e50;
  color: #ecf0f1;
  padding: 1.5rem;
  border-radius: 12px;
  font-family: 'Courier New', monospace;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  height: fit-content;
  position: sticky;
  top: 2rem;
  min-height: 400px;
}

.algorithm-panel h3 {
  color: #3498db;
  text-align: center;
  margin: 0 0 1.5rem 0;
  font-size: 1.1rem;
  font-weight: 600;
}

.algorithm-content {
  background: #34495e;
  padding: 1.5rem;
  border-radius: 8px;
  line-height: 1.8;
  font-size: 13px;
}

/* Enhanced Tutorial Highlighting System */
.part-1-highlight-active {
  background: #3498db !important;
  color: #ffffff !important;
  padding: 0.3rem 0.5rem;
  border-radius: 4px;
  transition: all 0.3s ease;
  box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
}

.part-2-highlight-active {
  background: #f39c12 !important;
  color: #2c3e50 !important;
  padding: 0.3rem 0.5rem;
  border-radius: 4px;
  transition: all 0.3s ease;
  box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
}

.part-2-alt-highlight-active {
  background: #1ff0e9 !important;
  color: #000000 !important;
  padding: 0.3rem 0.5rem;
  border-radius: 4px;
  transition: all 0.3s ease;
  box-shadow: 0 0 8px rgba(241, 196, 15, 0.6);
}

.part-3-highlight-active {
  background: #9b59b6 !important;
  color: #ffffff !important;
  padding: 0.3rem 0.5rem;
  border-radius: 4px;
  transition: all 0.3s ease;
  box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
}

.part-4-highlight-active {
  background: #17a2b8 !important;
  color: #ffffff !important;
  padding: 0.3rem 0.5rem;
  border-radius: 4px;
  transition: all 0.3s ease;
  box-shadow: 0 0 10px rgba(23, 162, 184, 0.5);
}

/* Mathematical term visibility control */
.math-complete-only {
  display: none;
}

.math-simple-only {
  display: inline;
}

body.tutorial-part-4 .math-complete-only,
body.playground-mode .math-complete-only {
  display: inline;
}

body.tutorial-part-4 .math-simple-only,
body.playground-mode .math-simple-only {
  display: none;
}

/* Introduction Mode Styles */
.introduction-section {
  text-align: center;
  margin-bottom: 3rem;
}

.introduction-content {
  background: rgba(255, 255, 255, 0.95);
  padding: 3rem 2rem;
  border-radius: 16px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.15);
  max-width: 800px;
  margin: 0 auto 2rem auto;
  backdrop-filter: blur(10px);
}

.introduction-content h2 {
  color: #2c3e50;
  margin: 0 0 1.5rem 0;
  font-size: 2rem;
  font-weight: 600;
}

.introduction-content p {
  color: #555;
  font-size: 1.1rem;
  line-height: 1.7;
  margin-bottom: 1.5rem;
}

/* Mode visibility classes */
.introduction-only { display: block; }
.tutorial-only { display: none; }
.playground-only { display: none; }

/* Introduction mode - show both introduction-only and tutorial-only elements */
body:not(.tutorial-mode):not(.playground-mode) .introduction-only { display: block; }
body:not(.tutorial-mode):not(.playground-mode) .tutorial-only { display: block; }

/* Tutorial mode */
body.tutorial-mode .introduction-only { display: none; }
body.tutorial-mode .tutorial-only { display: block; }
body.tutorial-mode .playground-only { display: none; }

/* Playground mode */
body.playground-mode .introduction-only { display: none; }
body.playground-mode .tutorial-only { display: none; }
body.playground-mode .playground-only { display: block; }

/* Tutorial part-specific visibility */
.tutorial-part-1-only { display: none; }
.tutorial-part-2-plus { display: none; }
.tutorial-part-3-plus { display: none; }
.tutorial-part-2-only { display: none; }

body.tutorial-part-1 .tutorial-part-1-only { display: block; }
body.tutorial-part-2 .tutorial-part-2-plus,
body.tutorial-part-3 .tutorial-part-2-plus,
body.tutorial-part-4 .tutorial-part-2-plus { display: block; }
body.tutorial-part-3 .tutorial-part-3-plus,
body.tutorial-part-4 .tutorial-part-3-plus { display: block; }
body.tutorial-part-2 .tutorial-part-2-only { display: block; }

/* Explicitly hide tutorial settings in parts 1, 3, and 4 */
body.tutorial-part-1 .tutorial-part-2-only,
body.tutorial-part-3 .tutorial-part-2-only,
body.tutorial-part-4 .tutorial-part-2-only {
  display: none !important;
}

/* Hide canvas and controls for tutorial part 4 */
body.tutorial-part-4 .main-layout {
  display: none !important;
}

/* Manual controls visibility - only part 1 */
body.tutorial-part-2 .collapsible-section.tutorial-only.playground-only,
body.tutorial-part-3 .collapsible-section.tutorial-only.playground-only,
body.tutorial-part-4 .collapsible-section.tutorial-only.playground-only {
  display: none !important;
}

/* Force manual controls to be visible in tutorial part 1 only */
body.tutorial-part-1 .collapsible-section.tutorial-only.playground-only {
  display: block !important;
  visibility: visible !important;
}

body.tutorial-part-1 .collapsible-section.tutorial-only.playground-only .collapsible-content {
  display: block !important;
}

body.tutorial-part-1 .collapsible-section.tutorial-only.playground-only .collapsible-toggle {
  transform: rotate(180deg);
}

/* Manual controls hidden in parts 2, 3, and 4 */
body.tutorial-part-2 .collapsible-section.tutorial-only.playground-only,
body.tutorial-part-3 .collapsible-section.tutorial-only.playground-only,
body.tutorial-part-4 .collapsible-section.tutorial-only.playground-only {
  display: none !important;
}

/* Responsive Tutorial Layout */
@media (max-width: 1200px) {
  .tutorial-container-wrapper {
    max-width: 100% !important;
    margin: 1rem !important;
  }
  
  .tutorial-global-header {
    margin-bottom: 1rem !important;
    padding: 1.5rem !important;
  }
  
  .tutorial-global-header h2 {
    font-size: 1.4rem !important;
  }
  
  .tutorial-container {
    flex-direction: column !important;
    gap: 1.5rem !important;
    max-width: 100% !important;
  }
  
  .tutorial-content-panel {
    max-width: 100% !important;
  }
  
  .algorithm-panel {
    flex: none !important;
    position: relative !important;
    top: auto !important;
    order: -1; /* Show algorithm first on mobile */
    width: 100%;
    max-width: 100%;
  }
}

/* Force horizontal layout on larger screens */
@media (min-width: 1201px) {
  .tutorial-container {
    display: flex !important;
    flex-direction: row !important;
  }
  
  .tutorial-content-panel {
    flex: 1 !important;
    max-width: calc(100% - 600px) !important; /* Updated for 550px algorithm panel + gap */
  }
  
  .algorithm-panel {
    flex: 0 0 550px !important; /* Updated to 550px */
    position: sticky !important;
    top: 2rem !important;
  }
}
/* Actions panel for both introduction and tutorial modes */
.non-playground-actions {
  display: flex;
}

body.playground-mode .non-playground-actions {
  display: none;
}
  </style>
</head>
<body>
  <header>
    <h1>Learn Value Iteration!</h1>
    <p>
      <span id="header-subtitle">Learn how value iteration works step by step</span>
      <br>
      <a href="https://michaelfellner.github.io" style="color: #bbdefb; text-decoration: underline; font-weight: 500;">← Back to Homepage</a>
    </p>
    <div class="mode-toggle">
      <button class="mode-btn active" id="introduction-mode-btn" onclick="switchToIntroductionMode()">Introduction</button>
      <button class="mode-btn" id="tutorial-mode-btn" onclick="switchToTutorialMode()">Tutorial Mode</button>
      <button class="mode-btn" id="playground-mode-btn" onclick="switchToPlaygroundMode()">Playground Mode</button>
    </div>
  </header>

  <!-- Introduction Mode Content -->
  <main class="introduction-only">
    <section class="introduction-section">
      <div class="introduction-content">
        <h2>Value Iteration: How to Solve a Maze</h2>
        <p>
          Draw a path connecting the green square to the purple one, then click "run algorithm". Behind the scenes, <i>Value Iteration</i> will calculate 
          the best way for the green square to complete the maze you just drew. Afterwards, click "Start Tutorial" if you want to learn more and understand
          why this algorithm is so important to know before going further in reinforcement learning.
        </p>
      </div>
    </section>
  </main>

  <!-- Tutorial Mode Content - Side by Side Layout -->
  <div class="tutorial-only tutorial-container-wrapper">
    
    <!-- Tutorial Header (Above Both Panels) -->
    <div class="tutorial-global-header">
      <h2 id="tutorial-main-title">Tutorial Part 1: State, Actions, and the Value Function</h2>
      <div class="tutorial-navigation">
        <button onclick="switchTutorialPart(1)" id="part-1-btn-global" class="tutorial-nav-btn active">Part 1</button>
        <button onclick="switchTutorialPart(2)" id="part-2-btn-global" class="tutorial-nav-btn">Part 2</button>
        <button onclick="switchTutorialPart(3)" id="part-3-btn-global" class="tutorial-nav-btn">Part 3</button>
        <button onclick="switchTutorialPart(4)" id="part-4-btn-global" class="tutorial-nav-btn">Part 4</button>
      </div>
    </div>

    <!-- Tutorial Content and Algorithm Side by Side -->
    <div class="tutorial-container">
      
      <!-- Tutorial Content (Left Side) -->
      <section id="tutorial-explanation" class="tutorial-content-panel">
        <!-- Tutorial Part 1 -->
        <div id="tutorial-part-1" class="tutorial-part">
          <div class="tutorial-step">
            <h3>Introduction</h3>
            <p>Welcome to the Value Iteration Tutorial! Our goal is to understand this algorithm on the right. <b>NOTE:</b> Don't worry about understanding it right now, we 
                will walk through each line throughout this tutorial.</p>
                </div>
            <div class="tutorial-step"> 
                <h3>Let's Learn Some Terms</h3>
            <p>
                The green square below is your <b>agent</b>. Each tile the agent can go to is a <b>state</b>. The agent can take <b>actions</b> 
                that determine which state it goes to next. Try drawing a path and moving the agent around using the actions
                 (up, down, left, right). You’ll see in the bottom left which state the agent is at.  
            </p>
            <p>If the agent reaches the goal (the purple square), then it gets 100 <b>reward</b>. Or in other words, 
                goal states – states where the agent is at the goal –, have 100 reward. Every other state that isn’t at the goal has 0 reward.</p>
          </div>

          <div class="tutorial-step"> 
                <h3>A Very Important Term: What is Value?</h3>
            <p>
                Every state has ZERO reward except for the ones that touch the goal!? How will the agent figure out where to go? Which next state 
                is best for the agent to go to?
            </p>
            <p>This is where the notion of <b>value</b> comes in. Value is different than reward.
                 Value takes into account the potential of a state – how well it can lead to future rewards, even if the state itself offers no reward. 
          </div>
          
          <div class="tutorial-step">
            <h3>Putting it All Together</h3>
            <p>
                The point of this algorithm, Value Iteration, is to learn the value of each state. We are given the reward – but need to know which 
                states have the best potential for leading to reward. That way, when the agent is thinking about which direction to go
                 despite every future state all having zero reward, the agent can see which next state has the highest Value, and go there. 
                By continuously going  to the next states that have the most value, 
                the agent will keep taking optimal actions and manage to get the most amount of reward in the shortest amount of steps. 
                The roadmap an agent uses to navigate the maze is called a <b>policy</b> and if we always know which next state is best to go to,
                then we have an <b>optimal policy</b>.  
            </p>
          </div>
          <div class="tutorial-step">
            <h3><b>Experiment Below</b></h3>
            <p>
                First run value iteration to get a value for each state. Then feel free to manually move the agent either using the button controls or your <b>arrow keys</b>. See how 
                the value changes depending on where the agent moves to. Do the changes make sense?
            </p>
          </div>
        </div>

        <!-- Tutorial Part 2 -->
        <div id="tutorial-part-2" class="tutorial-part" style="display: none;">
          <div class="tutorial-step">
            <h3>Time to get Technical</h3>
            <p>We just learned about states, value, actions, and reward. Let’s look at some of the technical ways the pros talk about these things 😎</p>
            <p><b>States:</b> The current state is often referred to simply as <b>s</b>, and the next state is <b>s'</b>.
                 Every single possible state is referred to as the state-space, or <b>S</b> (yes the uppercase is important). Importantly, s and s’ are variables. 
                 They’re used to talk about what to do at some specific state in general. 
                 For example, you could say “for any s, take the action that brings you to the s’ with the highest value”. 
            </p>
            <p>
                <b>Actions:</b> An action variable is <b>a</b>. The set of all actions that can be taken at some specific state is <b>A(s)></b>. 
                Some states, don’t allow for some actions, like trying to go down while already at the bottom of the screen. 
            </p>
            <p>
                <b>Reward: </b><i>Technically</i> what is meant by "state s has reward x", is actually saying that there is a reward function, <b>r</b>, and r(s) = x.  
            </p>
            <p>
                <b>Value: </b>Similar to reward, value is also actually a function. We can refer to the value of a state as v(s), or a next state, v(s’). 
                 Unlike the reward function, we aren't given the correct value function at the start. The whole point of Value Iteration 
                 is to learn the correct value function when all we have is the reward function. 
            </p>
            <p>We can refer to the current value function as V, 
                which is meant to refer to how there is a whole function that can take in any state and output a value. 
                 So casually, the way this algorithm works is by starting out with a bad value function V, then some calculations and updates are made,
                  and we then create a new value function, V’.  Then we make V’ the new V and update things again. 
                We keep improving the value function until the improvements between V and V’ are so small that V can barely improve anymore.
            </p>
          </div>
        
          <div class="tutorial-step">
            <h3><span data-highlight-part="2">Iteratively Improving the Value Function</span></h3>
            <p>With our technical terms done we can start deciphering the algorithm on the right. First let’s understand the orange part. These lines are all about how we start with a bad value function V, get a better one V’, and then have V’ become V and start the process over again. </p>

<p><b>Line 1:</b> We start with an inaccurate value function that’s randomly initialized, or just assigns a value to zero to each state.</p>

<p><b>Lines 2 & 8:</b> Line 2 starts a loop, meaning that everything that happens beneath it keeps happening over and over again until the condition on line 8 is met. The specifics of line 8 and how the loop stops are in the next text blurb. But for now just know that everything in between lines 2 and 8 happen multiple times. We can also see that line 2 and 8 are on the same level of indentation. This is a means of signalling that line 8 is what has the power to stop the loop started on line 2. </p>

<p><b>Line 4:</b> Line 4 starts another loop. What line 4 is saying is that we are going to go through every single state, and then use it to do stuff on lines 5 and 6 (because lines 5 and 6 are indented below line 4. So we have a loop started on line 2, and then another loop started on line 4. The reason for this is because for value iteration to work, we need to loop through every single state (as per line 4), and we are going to need to loop through every single state <i>multiple times</i> (as per line 2).</p>

<p><b>Line 5:</b> So we’re going through each state (as per line 4). We have our current bad value function V that will give us the wrong value for whatever state we’re at, v(s). Line 5 is about how we go state by state and find a more accurate value for it – v’(s). (Once we’ve gotten v’(s) for every single state, we have a whole new value function V’, which we hope is superior to the current value function V). How v’(s) is calculated is in tutorial part 3. </p>

<p><b>Line 7:</b> After getting better values for every individual state, we have a whole new value function, V’. Line 7 simply says to now let V’ be the current value function V, and then if the condition on line 8 isn’t met, we start looping through every single state yet again. </p>
          </div>
          




        <div class="tutorial-step">
            <h3><span data-highlight-part="2-alt">How we Stop</span></h3>
            <p>Casually, the way we stop is by checking if the difference between V and V’ is small. Are any improvements to the value function barely any better, or even resulting in no new improvements at all? At that point, we stop and now have a good value function. So in order to do this, we need to track the difference between V and V’. We do so by tracking the largest difference that V gives for a state and V’ gives for a state. </p>

            <p><b>Line 3:</b> Line 3 initializes a variable, delta, to be zero. This is the variable that’s going to track the biggest change between V and V’. </p>

            <p><b>Line 6:</b> We just calculated a new value for some state, v(s’) on line 5. Line 6 is a way of keeping the delta to be the biggest (absolute) difference between v(s) and v(s’). This line might be easiest to understand by just carefully looking it over and thinking about it. </p>

            <p><b>Line 8:</b> If delta is less than a small threshold value theta, we stop the whole thing.</p>

          </div>
        <div class="tutorial-step">
            <h3><b>See the Value Function Improve Live</b></h3>
            <p>Click "Live Algorithm" after drawing a path and see the value of each state become more accurate!</p>
            
          </div>


        </div>

        
        
        

        <!-- Tutorial Part 3 -->
        <div id="tutorial-part-3" class="tutorial-part" style="display: none;">
          <div class="tutorial-step">
            <h3>Let's Watch the Value Function Improve <i>Live</i></h3>
            <p>We haven’t gone over exactly how the value function improves yet, but we do know that we iterate through each state and then make the value function better. To see the value function improve visually, draw a path and run the “live value iteration” function. You’ll then see the green box go to each state and update it from v(s) to v’(s). Run the algorithm multiple times and see how the delta gets smaller each iteration. </p>

<p>As each state is iterated, the more green a state is the higher its value, the more red a state is the lower its value. It will also leave what the current “best” action at each state is. You’ll be able to see that as the value function improves, the “best” actions become more likely to actually be the true best action.</p>

          </div>
          
          <div class="tutorial-step">
            <h3><span data-highlight-part="3">How the Value Function Improves</span></h3>
            <p>We can now understand the purple highlighted part. The way it works is that it finds the action that maximizes r(s') + γV(s'). s' means next state. Each action brings you to a different s' (most of the time, sometimes multiple actions can lead to the same next state). r(s') is the reward of the next state, and γV(s') is the value of the next state, multiplied by a constant γ.</p>
            <p>γ is the <b>discount rate</b>, and this determines how much the value of the next state should affect the current state. If it's 0, then that means we don't care about the value of the next state at all, therefore we only care about the reward. If it's 1 then that means we really care about the value of the next state. γ often equals 0.9, but in the background of this website, γ is actually set to 1, so it doesn't really matter that much. You can experiment more with γ in playground mode.</p>
            <p>To bring it all together, all the highlighted line is doing now is checking which action leads to the greatest r(s') + γV(s'), and then updates V(s) to be that maximum r(s') + γV(s').</p>
          </div> 

          <div class="tutorial-step">
            <h3><b>View Things Step-by-Step</b></h3>
            <p>
                You can now go step by step and see the whole picture of what’s going on in this algorithm at the closest level of detail. 
                Press the step by step button and you’ll be able to see live how the right side of Line 5 is calculated. Keep clicking next to 
                manually go through each state!
            </p>
          </div>    
        </div>

        <!-- Tutorial Part 4 -->
        <div id="tutorial-part-4" class="tutorial-part" style="display: none;">
          <div class="tutorial-step">
            <h3>Congratulations!</h3>
            <p>You've completed the Value Iteration tutorial! You now understand the core concepts of:</p>
            <ul>
              <li><strong>States and Actions</strong> - The building blocks of any reinforcement learning environment</li>
              <li><strong>Value Functions</strong> - How we estimate the worth of being in different states</li>
              <li><strong>The Iterative Process</strong> - How value iteration gradually improves our estimates</li>
              <li><strong>Policy Extraction</strong> - How optimal actions emerge from accurate value functions</li>
            </ul>
          </div>
          
          <div class="tutorial-step">
            <h3><span data-highlight-part="4">Advanced Caveats</span></h3>
            <p>This whole time we've actually been looking at a slightly simplified version of value iteration. The blue parts are parts that were removed in steps 1-3.</p>
            <ul>
              <li><b>P(s'|s,a):</b> This part is relevant if actions operated probabilistically. Because this whole time we've been in a deterministic environment, it was irrelevant. But what this part means is "the probability of going to state s' given you're in state s and taking action a.</li>
              <li><b>r(s,a,s'):</b> Technically, the reward function is best described not just as r(s'), but as a function of the current state you're in 's', the action you're taking 'a', and also the state you end up in, s' (hence r(s,a,s')). For this environment, r(s') was good enough, but imagine in a different environment, there's some state s', but to get to it from the north you must go through lava while walking on your hands, but to get to it from the south, you simply walk through an air conditioned hallway. In this case, you don't want the reward to just factor in the destination, but the journey as well.</li>
              <li><b>∑<sub>s'</sub>:</b> This last little part... is actually a huge deal! In a deterministic environment, it is not necessary. A "deterministic environment", meaning that each action leads to only one next state 100% of the time. This website is a deterministic environment. But in a probabilistic environment, where actions can potentially lead to multiple different states, this summation term is crucial. What this term means is that for each action, we can't just take into account r(s') + γV(s') for a single next state, but instead we have to take into account r(s') + γV(s') for every potential next state! We sum the r(s') + γV(s') for <i>every</i> possible next state, and weigh each [r(s') + γV(s')] by the probability of ending up in that s'. This adds another loop to the value iteration algorithm and causes things to move much slower. It is actually the nature of a probabilistic environment that is a big reason for why <i>reinforcement learning</i> is used in many cases instead of value iteration.</li>
            </ul>
          </div>
          
          <div class="tutorial-step" style="text-align: center; background: #e8f5e9; border: 2px solid #4CAF50;">
            <h3 style="color: #2e7d32; margin-bottom: 1rem;">🚀 Ready to Explore?</h3>
            <p style="margin-bottom: 1.5rem; color: #555;">Now that you understand the theory, experiment with different parameters and environments!</p>
            <button onclick="switchToPlaygroundMode()" class="btn-primary" style="padding: 12px 24px; font-size: 16px; font-weight: 600;">Go to Playground Mode</button>
          </div>
        </div>
      </section>
      <!-- Algorithm Display (Right Side) -->
      <section class="algorithm-panel">
        <h3>Value Iteration Algorithm</h3>
        <div class="algorithm-content">
          <div style="margin-bottom: 1rem;"><strong>1.</strong> <span data-highlight-part="2"><em>V</em> to arbitrary value function; e.g., <em>V(s)</em> = 0 for all <em>s</em></span></div>
          <div style="margin-bottom: 1rem;"><strong>2.</strong> <strong>repeat</strong></div>
          <div style="margin-left: 2rem; margin-bottom: 1rem;"><strong>3.</strong> <span data-highlight-part="2-alt">Δ ← 0</span></div>
          <div style="margin-left: 2rem; margin-bottom: 1rem;"><strong>4.</strong> <span data-highlight-part="2"><strong>for each</strong> <em>s</em> ∈ <em>S</em></span></div>
          <div style="margin-left: 4rem; margin-bottom: 1rem;">
            <strong>5.</strong> <span data-highlight-part="2"><em>V'(s)</em> ←</span> 
            <span data-highlight-part="3">max<sub>a∈A(s)</sub></span>
            <span class="math-complete-only" data-highlight-part="4">∑<sub>s'</sub> P(s'|s,a)</span>
            <span data-highlight-part="3">[<span class="math-simple-only"><em>r(s')</em></span><span class="math-complete-only"><em>r(s,a,s')</em></span> + γ <em>V(s')</em>]</span>
          </div>
          <div style="margin-left: 4rem; margin-bottom: 1rem;"><strong>6.</strong> <span data-highlight-part="2-alt">Δ ← max(Δ, |<em>V'(s)</em> - <em>V(s)</em>|)</span></div>
          <div style="margin-left: 2rem; margin-bottom: 1rem;"><strong>7.</strong> <span data-highlight-part="2"><em>V</em> ← <em>V'</em></span></div>
          <div style="margin-bottom: 1.5rem;"><strong>8.</strong> <span data-highlight-part="2-alt"><strong>until</strong> Δ ≤ θ</span></div>
          
          <!-- Source Note -->
          <!-- <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #4a5568; font-size: 11px; color: #a0aec0; text-align: center;">
            <em>Source: insertlater.com</em>
          </div> -->
        </div>
      </section>

    </div>
    </div>
  </div>

  <!-- Main Layout with Canvas + Actions + Parameters -->
  <main>
    <div class="main-layout">
      
      <!-- Actions Panel (Left) - Playground Mode Only -->
      <div class="actions-panel playground-only">
        <div class="playground-section">
          <h4>🚀 Actions</h4>
          <div class="playground-actions">
            <button onclick="runValueIterationClientSide()" class="btn-primary">Run Value Iteration</button>
            <button onclick="runLiveValueIteration()" class="btn-secondary">Live Animation</button>
            <button onclick="runLiveValueIteration_step_by_step()" class="btn-tutorial">Step-by-Step Mode</button>
            <button onclick="followValuePolicy()" class="btn-accent">Follow Policy</button>
          </div>

          <!-- Manual Controls -->
          <div style="margin-top: 1rem;">
            <h5 style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #666; text-transform: uppercase;">Manual Control</h5>
            <div class="dpad-grid" style="max-width: 120px; margin: 0;">
              <div></div>
              <button onclick="manualMove(0)">↑</button>
              <div></div>
              <button onclick="manualMove(2)">←</button>
              <div style="font-size: 10px;">move</div>
              <button onclick="manualMove(3)">→</button>
              <div></div>
              <button onclick="manualMove(1)">↓</button>
              <div></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Actions Panel for Tutorial/Introduction modes -->
      <div class="actions-panel non-playground-actions">
        
        <!-- Main Actions -->
        <div class="sidebar-section">
          <h3>🚀 Actions</h3>
          
          <!-- Introduction Mode Actions -->
          <div class="introduction-only">
            <div class="button-row">
              <button onclick="runValueIterationDemo()" class="btn-primary">Solve the Maze!</button>
            </div>
            <div class="button-row">
              <button onclick="followOptimalPath()" id="follow-path-btn" class="btn-secondary" style="display: none;">🎯 Follow Path</button>
            </div>
            <div id="intro-status" class="status-display" style="display: none; margin-top: 0.5rem;">
              <strong>Status:</strong> <span id="status-text">Ready</span>
            </div>
          </div>

          <!-- Tutorial Mode Actions -->
          <div class="tutorial-only">
            <div id="tutorial-part-1-controls" class="tutorial-controls-part">
              
              <div class="button-row">
                <button onclick="runValueIterationClientSide()" class="btn-primary">Run Value Iteration</button>
              </div>
              <div class="button-row">
                <button onclick="followValuePolicy()" class="btn-accent">Follow Policy</button>
              </div>
            </div>

            <div id="tutorial-part-2-controls" class="tutorial-controls-part" style="display: none;">
            <!-- Live Algorithm and Follow Policy for Part 2 -->
            <div style="margin-top: 0rem;">
                <h4 style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Live Mode</h4>
                <div class="button-row">
                <button onclick="runTutorialLiveValueIteration()" class="btn-secondary">Live Algorithm</button>
                </div>
                <div class="button-row">
                <button onclick="followValuePolicy()" class="btn-accent">Follow Live Policy</button>
                </div>
            </div>
            </div>

            <div id="tutorial-part-3-controls" class="tutorial-controls-part" style="display: none;">
              <!-- Only Step-by-Step Mode for Part 3 -->
              <div style="margin-top: 0rem;">
                <h4 style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Step-by-Step Mode</h4>
                <div class="button-row">
                  <button onclick="runLiveValueIteration_step_by_step()" class="btn-tutorial">Step-by-Step</button>
                </div>
              </div>
            </div>
          </div>
        </div>
                    
        <!-- Introduction Tutorial Prompt -->
        <div class="sidebar-section introduction-only">
          <h3>Tips</h3>
          <div class="button-row">
            <ul><li>Click "reset agent" if the green square gets stuck in an inifinite loop.</li>
            <li>
                Click "reset all" to try a new path.
            </li></ul>
          </div>
        </div>

        <div class="sidebar-section introduction-only">
          <h3>🎓 Learn More</h3>
          <div class="button-row">
            <button onclick="switchToTutorialMode()" class="btn-tutorial">Start Tutorial</button>
          </div>
        </div>

        <!-- Manual Movement (Tutorial only) -->
        <div class="collapsible-section tutorial-only">
          <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <h3>🕹️ Manual Control</h3>
            <span class="collapsible-toggle">▼</span>
          </div>
          <div class="collapsible-content">
            <div class="dpad-grid">
              <div></div>
              <button onclick="manualMove(0)">↑</button>
              <div></div>
              <button onclick="manualMove(2)">←</button>
              <div>move</div>
              <button onclick="manualMove(3)">→</button>
              <div></div>
              <button onclick="manualMove(1)">↓</button>
              <div></div>
            </div>
          </div>
        </div>

        <!-- Tutorial Settings (Part 2 only) -->
        <div class="collapsible-section tutorial-only tutorial-part-2-only">
          <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <h3>Live Animation Settings</h3>
            <span class="collapsible-toggle">▼</span>
          </div>
          <div class="collapsible-content">
            <div class="input-group">
              <label>Speed:</label>
              <input id="tutorialDelayMs" type="number" value="200" min="50" max="1000">
              <span style="font-size: 10px; color: #666;">ms</span>
            </div>
            <div class="input-group">
              <label>Iterations:</label>
              <input id="tutorialLiveIters" type="number" value="1" min="1" max="5">
            </div>
          </div>
        </div>

        <!-- Tutorial Navigation (Single, Dynamic) -->
        <div class="sidebar-section tutorial-only">
          <h3>📍 Navigation</h3>
          <div class="button-row">
            <button id="tutorial-nav-left" onclick="switchToIntroductionMode()" class="btn-secondary">← Back to Intro</button>
            <button id="tutorial-nav-right" onclick="switchTutorialPart(2)" class="btn-primary">Part 2 →</button>
          </div>
        </div>

        <!-- Hidden status elements (keep for JavaScript compatibility) -->
        <div style="display: none;">
          <div id="agentPosition" class="playground-only">The agent is currently at state (60, 540)</div>
          <div id="tutorialAgentPosition" class="tutorial-only">The agent is currently at state (60, 540)</div>
          <div id="iterationCount">Iterations: -</div>
          <div id="deltaDisplay">Δ: -</div>
          <div id="pathCheckResult">Path: -</div>
        </div>

      </div>
      
      <!-- Canvas Section with Controls and Status Bars -->
      <div class="canvas-and-controls">
        <!-- Compact Canvas Controls Bar -->
        <div class="canvas-controls-bar">
          <!-- Canvas Size Dropdown -->
          <div class="canvas-size-compact">
            <label>Canvas:</label>
            <select onchange="resizeCanvas(this.value)">
              <option value="small" selected>Small (600×360)</option>
              <option value="medium">Medium (800×480)</option>
              <option value="large">Large (1000×600)</option>
            </select>
          </div>

          <!-- Reset Buttons -->
          <div class="canvas-reset-buttons">
            <button onclick="resetGreenBox()" class="btn-mini btn-primary" title="Reset agent position">Reset Agent</button>
            <button onclick="resetEverything()" class="btn-mini btn-danger" title="Reset everything">Reset All</button>
          </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
          <canvas id="c" width="1000" height="600"></canvas>
        </div>

        <!-- Canvas Status Bar with External Step-by-Step Buttons -->
        <div class="canvas-status-bar-wrapper">
          <!-- Left: Stop Button (Outside) -->
          <div id="stepByStepStopContainer" style="display: none;">
            <button onclick="stopStepByStep()" class="btn-mini btn-danger">🛑 Stop</button>
          </div>
          
          <!-- Center: Canvas Status Bar -->
          <div class="canvas-status-bar">
            <!-- Status Info -->
            <div class="status-info">
            <div id="agentPositionCompact" class="agent-status-compact">
                Agent: (60, 540)
            </div>
            <div id="currentRewardCompact" class="agent-status-compact">
                Reward: 0
            </div>
            <div id="currentValueCompact" class="agent-status-compact">
                Value: -
            </div>
            </div>

            <div class="status-info">
              <div id="iterationCountCompact" class="iteration-status-compact">
                Iterations: -
              </div>
              <div id="deltaDisplayCompact" class="iteration-status-compact">
                Δ: -
              </div>
            </div>
          </div>
          
          <!-- Right: Next Step Button (Outside) -->
          <div id="stepByStepNextContainer" style="display: none;">
            <button onclick="nextStepClick()" class="btn-mini btn-primary">▶️ Next</button>
          </div>
        </div>

        <!-- Step-by-Step Status Bar (hidden by default) -->
        <div id="stepByStepStatusBar" style="display: none;">
          <div class="status-info" style="width: 100%; justify-content: center;">
            <div id="stepByStepStatus" style="font-size: 12px; font-weight: 600; color: black; padding: 8px 12px; text-align: center; font-family: 'Courier New', monospace; line-height: 1.3;">
              Ready to start step-by-step analysis...
            </div>
          </div>
        </div>
      </div>

      <!-- Parameters Panel (Right) - Playground Mode Only -->
      <div class="parameters-panel playground-only">
        <div class="playground-section">
          <h4>⚙️ Parameters</h4>
          <div class="playground-params">
            <div class="input-group">
              <label>Discount Factor (γ):</label>
              <input id="gamma" type="number" step="0.01" value="0.99" onchange="updateParameterDisplays()">
            </div>
            <div class="input-group">
              <label>Convergence Threshold (ε):</label>
              <input id="threshold" type="number" step="1e-6" value="0.0001" onchange="updateParameterDisplays()">
            </div>
            <div class="input-group">
              <label>Reward Function:</label>
              <select id="rewardFunction" onchange="updateParameterDisplays()">
                <option value="zero">Zero reward</option>
                <option value="negative_distance">Negative distance</option>
              </select>
            </div>
            <div class="input-group">
              <label>Animation Delay (ms):</label>
              <input id="delayMs" type="number" value="120" min="10" max="2000">
            </div>
            <div class="input-group">
              <label>Iterations per Run:</label>
              <input id="liveIters" type="number" value="1" min="1" max="10">
            </div>
          </div>
        </div>
      </div>

    </div>
  </main>

  <script src="draw.js"></script>
  <script>
    // Store the original function references
    let originalFollowValuePolicy;
    let originalFollowOptimalPath;

    // Collapsible section functionality
    function toggleCollapsible(header) {
      const content = header.nextElementSibling;
      const toggle = header.querySelector('.collapsible-toggle');
      
      if (content.classList.contains('expanded')) {
        content.classList.remove('expanded');
        toggle.classList.remove('expanded');
        content.style.display = 'none';
      } else {
        content.classList.add('expanded');
        toggle.classList.add('expanded');
        content.style.display = 'block';
      }
    }
    
    // Update canvas size dropdown when canvas is resized
    function updateCanvasSizeDropdown(size) {
      const dropdown = document.querySelector('.canvas-size-compact select');
      if (dropdown) {
        dropdown.value = size;
      }
    }
    
    // Update controls bar width to match canvas width and handle step-by-step status bar
    function updateControlsBarWidth(size) {
      const controlsBar = document.querySelector('.canvas-controls-bar');
      const statusBarWrapper = document.querySelector('.canvas-status-bar-wrapper');
      const stepByStepStatusBar = document.getElementById('stepByStepStatusBar');
      const canvasSizes = {
        small: '600px',
        medium: '800px', 
        large: '1000px'
      };
      
      if (controlsBar && canvasSizes[size]) {
        controlsBar.style.width = canvasSizes[size];
      }
      
      // Update status bar wrapper width to match canvas
      if (statusBarWrapper && canvasSizes[size]) {
        statusBarWrapper.style.width = canvasSizes[size];
      }
      
      // Update step-by-step status bar
      if (stepByStepStatusBar && canvasSizes[size]) {
        stepByStepStatusBar.style.width = canvasSizes[size];
        // Ensure minimum width for step-by-step status bar
        const minWidth = Math.max(parseInt(canvasSizes[size]), 800);
        stepByStepStatusBar.style.minWidth = `${minWidth}px`;
      }
    }
    
    // Update compact status displays when original ones are updated
    function updateCompactStatusDisplays() {
      // Update agent position display (single display for both modes)
      const agentPosition = document.getElementById('agentPosition');
      const tutorialAgentPosition = document.getElementById('tutorialAgentPosition');
      const agentPositionCompact = document.getElementById('agentPositionCompact');
      
      if (agentPositionCompact) {
        let text = '';
        if (agentPosition && agentPosition.textContent) {
          text = agentPosition.textContent;
        } else if (tutorialAgentPosition && tutorialAgentPosition.textContent) {
          text = tutorialAgentPosition.textContent;
        }
        
        if (text) {
          const match = text.match(/\((\d+), (\d+)\)/);
          if (match) {
            agentPositionCompact.textContent = `Agent: (${match[1]}, ${match[2]})`;
          }
        }
      }
      
      // Update iteration count
      const iterationCount = document.getElementById('iterationCount');
      const iterationCountCompact = document.getElementById('iterationCountCompact');
      if (iterationCount && iterationCountCompact) {
        iterationCountCompact.textContent = iterationCount.textContent;
      }
      
      // Update delta display (always show, not just in playground mode)
      const deltaDisplay = document.getElementById('deltaDisplay');
      const deltaDisplayCompact = document.getElementById('deltaDisplayCompact');
      if (deltaDisplay && deltaDisplayCompact) {
        deltaDisplayCompact.textContent = deltaDisplay.textContent;
      }
    }
    
    // Updated layout function to prevent shifting
    function updateCanvasControlsLayout() {
      const mainLayout = document.querySelector('.main-layout');
      if (mainLayout) {
        mainLayout.style.alignItems = 'flex-start'; // Prevent centering that causes shifts
      }
      
      const canvasAndControls = document.querySelector('.canvas-and-controls');
      if (canvasAndControls) {
        canvasAndControls.style.position = 'relative';
        canvasAndControls.style.width = 'auto';
      }
      
      const actionsPanel = document.querySelector('.actions-panel');
      if (actionsPanel) {
        actionsPanel.style.position = 'relative';
        actionsPanel.style.flexShrink = '0'; // Prevent shrinking
      }
    }
    
    // Set up observers to watch for changes in the original status displays
    function setupStatusObservers() {
      const elementsToWatch = [
        'agentPosition',
        'tutorialAgentPosition', 
        'iterationCount',
        'deltaDisplay'
      ];
      
      elementsToWatch.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          const observer = new MutationObserver(updateCompactStatusDisplays);
          observer.observe(element, { 
            childList: true, 
            subtree: true, 
            characterData: true,
            attributes: true,
            attributeFilter: ['style']
          });
        }
      });
    }
    
    // Override the original resizeCanvas function to update dropdown and controls width
    const originalResizeCanvas = window.resizeCanvas;
    window.resizeCanvas = function(size) {
      if (originalResizeCanvas) {
        originalResizeCanvas(size);
      }
      updateCanvasSizeDropdown(size);
      updateControlsBarWidth(size);
    };
    
    // Override switchToTutorialMode to add scroll to top
    const originalSwitchToTutorialMode = window.switchToTutorialMode;
    window.switchToTutorialMode = function() {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("🛑 Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchToTutorialMode) {
        originalSwitchToTutorialMode();
      }
      
      // Initialize navigation for part 1
      updateTutorialNavigation(1);
      
      // Initialize global header for part 1
      updateGlobalTutorialHeader(1);
      
      // Smooth scroll to top of page
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Function to update tutorial navigation buttons
    function updateTutorialNavigation(partNumber) {
      const leftButton = document.getElementById('tutorial-nav-left');
      const rightButton = document.getElementById('tutorial-nav-right');
      
      if (!leftButton || !rightButton) return;
      
      switch(partNumber) {
        case 1:
          leftButton.textContent = '← Back to Intro';
          leftButton.onclick = () => switchToIntroductionMode();
          rightButton.textContent = 'Part 2 →';
          rightButton.onclick = () => switchTutorialPart(2);
          break;
        case 2:
          leftButton.textContent = '← Part 1';
          leftButton.onclick = () => switchTutorialPart(1);
          rightButton.textContent = 'Part 3 →';
          rightButton.onclick = () => switchTutorialPart(3);
          break;
        case 3:
          leftButton.textContent = '← Part 2';
          leftButton.onclick = () => switchTutorialPart(2);
          rightButton.textContent = 'Part 4 →';
          rightButton.onclick = () => switchTutorialPart(4);
          break;
        case 4:
          leftButton.textContent = '← Part 3';
          leftButton.onclick = () => switchTutorialPart(3);
          rightButton.textContent = 'Playground →';
          rightButton.onclick = () => switchToPlaygroundMode();
          break;
      }
    }
    
    // Function to update global tutorial header
    function updateGlobalTutorialHeader(partNumber) {
      const titles = {
        1: "Tutorial Part 1: State, Actions, and the Value Function",
        2: "Tutorial Part 2: Putting the \"Iteration\" in Value Iteration", 
        3: "Tutorial Part 3: Step-by-Step Analysis",
        4: "Tutorial Part 4: Final Caveats"
      };
      
      const titleElement = document.getElementById('tutorial-main-title');
      if (titleElement && titles[partNumber]) {
        titleElement.textContent = titles[partNumber];
      }
      
      // Update global navigation buttons
      const globalButtons = [
        'part-1-btn-global',
        'part-2-btn-global', 
        'part-3-btn-global',
        'part-4-btn-global'
      ];
      
      globalButtons.forEach((btnId, index) => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.classList.toggle('active', index + 1 === partNumber);
        }
      });
    }
    
    // Override switchTutorialPart to handle body classes for part-specific visibility
    const originalSwitchTutorialPart = window.switchTutorialPart;
    window.switchTutorialPart = function(partNumber) {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("🛑 Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchTutorialPart) {
        originalSwitchTutorialPart(partNumber);
      }
      
      // Remove existing tutorial part classes
      document.body.classList.remove('tutorial-part-1', 'tutorial-part-2', 'tutorial-part-3', 'tutorial-part-4');
      
      // Add current tutorial part class
      document.body.classList.add(`tutorial-part-${partNumber}`);
      
      // Update navigation buttons
      updateTutorialNavigation(partNumber);
      
      // Update global header
      updateGlobalTutorialHeader(partNumber);
    };
    
    // Override switchToIntroductionMode to ensure proper cleanup
    const originalSwitchToIntroductionMode = window.switchToIntroductionMode;
    window.switchToIntroductionMode = function() {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("🛑 Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchToIntroductionMode) {
        originalSwitchToIntroductionMode();
      }
      
      // Remove tutorial part classes when going back to introduction
      document.body.classList.remove('tutorial-part-1', 'tutorial-part-2', 'tutorial-part-3', 'tutorial-part-4');
      
      // Smooth scroll to top of page
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Override switchToPlaygroundMode to stop step-by-step
    const originalSwitchToPlaygroundMode = window.switchToPlaygroundMode;
    window.switchToPlaygroundMode = function() {
      // Stop step-by-step if it's running (additional check)
      if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
        console.log("🛑 Stopping step-by-step due to navigation (HTML override)");
        if (typeof stopStepByStep === 'function') stopStepByStep();
      }
      
      if (originalSwitchToPlaygroundMode) {
        originalSwitchToPlaygroundMode();
      }
      
      // Smooth scroll to top of page
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    // Initialize everything when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Set up proper layout to prevent shifts
      updateCanvasControlsLayout();

      // Override followValuePolicy with position updating version
      originalFollowValuePolicy = window.followValuePolicy;
      if (originalFollowValuePolicy) {
        window.followValuePolicy = async function() {
          if (!valuePolicy || Object.keys(valuePolicy).length === 0) {
            console.warn("⚠️ No policy loaded. Run value iteration first.");
            alert("Please run value iteration first.");
            return;
          }
        
          stopFollowingPolicy = false;
          console.log("📌 Policy Keys:", Object.keys(valuePolicy));
        
          let steps = 0;
          while (steps < 1000) {
            if (stopFollowingPolicy) {
              console.log("🛑 Policy execution stopped.");
              break;
            }
        
            const cx = Math.floor((greenBox.left + BOX / 2) / BOX) * BOX;
            const cy = Math.floor((greenBox.top + BOX / 2) / BOX) * BOX;
            const key = `${cx},${cy}`;
            const action = valuePolicy[key];
            console.log(`🔍 At (${cx}, ${cy}) → action:`, action);
        
            if (action === undefined) {
              console.warn("❌ No action found in policy for current position.");
              break;
            }
        
            const [dx, dy] = { 0: [0, -BOX], 1: [0, BOX], 2: [-BOX, 0], 3: [BOX, 0] }[action];
            const nx = greenBox.left + dx;
            const ny = greenBox.top + dy;
        
            greenBox.set({ left: nx, top: ny });
            canvas.renderAll();
            
            // Update agent position display after each move
            const centerX = nx + BOX / 2;
            const centerY = ny + BOX / 2;
            updateAgentPositionDisplay(centerX, centerY);
        
            const goal = getGoalCenter();
            const dist = Math.sqrt((centerX - goal.x) ** 2 + (centerY - goal.y) ** 2);
            console.log(`📏 Distance to goal: ${dist.toFixed(2)}`);
            if (dist < BOX + 1) {
              console.log("🏁 Goal reached!");
              break;
            }
        
            await new Promise(r => setTimeout(r, 100));
            steps++;
          }
        
          console.log("🛑 Finished following policy.");
        };
      }
      
      // Also override followOptimalPath for introduction mode
      originalFollowOptimalPath = window.followOptimalPath;
      if (originalFollowOptimalPath) {
        window.followOptimalPath = function() {
          // Call original function and then ensure displays are updated
          originalFollowOptimalPath();
          // The original function should handle the position updates
        };
      }

      // Auto-expand important sections (only in tutorial mode)
      const importantSections = [
        '.collapsible-section .collapsible-header'
      ];
      
      // Only auto-expand in tutorial mode
      if (document.body.classList.contains('tutorial-mode')) {
        importantSections.forEach(selector => {
          const headers = document.querySelectorAll(selector);
          headers.forEach(header => {
            // Only expand the first two sections by default
            const section = header.closest('.collapsible-section');
            const allSections = Array.from(document.querySelectorAll('.collapsible-section'));
            const index = allSections.indexOf(section);
            
            if (index < 2) {
              toggleCollapsible(header);
            }
          });
        });
      }
      
      // Set initial canvas size dropdown and controls bar width
      updateCanvasSizeDropdown('small');
      updateControlsBarWidth('small');
      
      // Set up status observers and initial compact displays
      setupStatusObservers();
      updateCompactStatusDisplays();
      
      // Initialize tutorial part 1 class if in tutorial mode
      if (document.body.classList.contains('tutorial-mode')) {
        document.body.classList.add('tutorial-part-1');
        updateTutorialNavigation(1);
        updateGlobalTutorialHeader(1);
      }
    });
// Keyboard controls for agent movement
document.addEventListener('keydown', function(event) {
  // Only allow keyboard controls if not in step-by-step mode
  if (window._isLiveRunning && (typeof stepByStepPaused !== 'undefined' && stepByStepPaused)) {
    return; // Don't interfere with step-by-step mode
  }
  
  // Prevent default behavior for arrow keys to avoid page scrolling
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
    event.preventDefault();
  }
  
  // Map keys to actions
  switch(event.code) {
    case 'ArrowUp':
    case 'KeyW':
      manualMove(0); // Up
      break;
    case 'ArrowDown':
    case 'KeyS':
      manualMove(1); // Down
      break;
    case 'ArrowLeft':
    case 'KeyA':
      manualMove(2); // Left
      break;
    case 'ArrowRight':
    case 'KeyD':
      manualMove(3); // Right
      break;
  }
});
// Function to get current state reward
function getCurrentStateReward(x, y) {
  if (typeof getGoalCenter !== 'function') {
    return 0;
  }
  
  const goal = getGoalCenter();
  const dist = Math.sqrt((x - goal.x) ** 2 + (y - goal.y) ** 2);
  
  if (dist < 21) { // At goal
    return 10;
  }
  
  // Get current reward function setting
  const rewardFunction = document.getElementById('rewardFunction')?.value || 'zero';
  
  if (rewardFunction === 'negative_distance') {
    // Negative distance to goal (normalized by box size)
    return -(dist / 20);
  } else {
    // Zero reward (default)
    return 0;
  }
}

// Function to get current state value
function getCurrentStateValue(x, y) {
  const stateKey = `${x},${y}`;
  
  // Check if we have values from any algorithm
  if (liveValues && liveValues.has(stateKey)) {
    return liveValues.get(stateKey);
  }
  
  // Check if at goal (fallback)
  if (typeof getGoalCenter === 'function') {
    const goal = getGoalCenter();
    const dist = Math.sqrt((x - goal.x) ** 2 + (y - goal.y) ** 2);
    if (dist < 21) {
      return 10; // Goal value
    }
  }
  
  return "-"; // No value available
}
// Function to update the displays
function updateCurrentStateDisplays(x, y) {
  const rewardDisplay = document.getElementById('currentRewardCompact');
  const valueDisplay = document.getElementById('currentValueCompact');
  
  if (rewardDisplay) {
    const reward = getCurrentStateReward(x, y);
    // Format reward display - show whole numbers for goal, decimals for negative distances
    const formattedReward = reward === 10 || reward === 0 ? reward.toString() : reward.toFixed(2);
    rewardDisplay.textContent = `Reward: ${formattedReward}`;
  }
  
  if (valueDisplay) {
    const value = getCurrentStateValue(x, y);
    if (value === "-") {
      valueDisplay.textContent = `Value: -`;
    } else if (value === "VI") {
      valueDisplay.textContent = `Value: VI run`;
    } else {
      const formattedValue = typeof value === 'number' ? value.toFixed(2) : value;
      valueDisplay.textContent = `Value: ${formattedValue}`;
    }
  }
}
  </script>
</body>
</html>